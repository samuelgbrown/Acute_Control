% This script will individually analyze a given set of data (one session).
% Each "set" of runs will be treated individually.
%
% The user must change directories to the location of the data and run the
% script, or navigate to the data "super directory" (the directory which
% contains all of the data directories).
%
% Data format: The data will be in two forms.
%
% The first will be .mat files.  There are two types of .mat files that are
% recognized by this program.  The first is the "online" .mat file,
% generated by the Matlab program "TDT_Control" during an experiment. These
% files will be named as "neuronStructYYYYMMDD_HHMM.mat", where the Y's,
% M's, D's, H's, and M's are replaced with the corresponding year, month,
% day, hour and minute that the file was produced. The second .mat file is
% the offline file, generated by clustering data offline using MClust.
% This is done by:
% 1. Run convertTankToNSE on a given experimental day's
% data.
% 2. Run MClust, using the LoadSE_NeuralynxNT loading engine to load
% the data in, sorting the data for each electrode (A or B) into a cluster,
% and saving that cluster as a .t file.
% 3. Run convertNSEMClustToNeuronStruct on the resulting .t files.
% This will produce a file named as "MC_neuronStructYYYYDDDD_HHMM.mat".
%
% The second data required will be TDT files, stored in folder(s), one for
% each recording session.  These will be named "Acute_YYYYMMDD(_NN)", where
% the Y's and M's represent the years and months.  The N's represent the
% number of the recording session, and the contents of the parentheses will
% only appear if there is more than 1 TDT directory.

% clc;
close all;

%% Set user parameters
% Files
% Modify the dataToAnalyze.txt file in each data directory, first line for
% the online sorts, second line for the offline sorts.  Each line should be
% a comma-separated list of file numbers for each file to be loaded, or
% "0" to load all files.
analyzeOnline = false; % Should the online sorts be analyzed?
analyzeOffline = true; % Should the offline sorts be analyzed?

generateAnalysisData = false; % Save all of the data that is produced for the plots

saveFigs = false; % Should the figures be saved to file?

useRepeatRunBugCorrectionIfNeeded = true; % Should the expected results matrix be corrected, because the data set had the third block bug? (bug fixed 6/5/19)
useFifthStimBugCorrectionIfNeeded = true; % (Used if there is a .mat saving problem, as in the fifth-stim bug for [20190315, 20190318, 20190322]) Should the TDT waveforms be used to determine the results of stimulations, or should we use the resultsData matrix in each neuronStruct?
savingExampleFigures = false; % Are the figures being plotted now being specifically chosen as examples?  If so, then ALL figures made will be sent to the exampleDir.

% dirsToRead = {...
%     '20191204',...
%     '20191216',...
%     }; %0; % Which directories to read(SET TO "0" TO ANALYZE ALL)

dirsToRead = 0; % Read all directories

% filesToAnalyze = [6]; % Files to analyze (SET TO "0" TO ANALYZE ALL)
trialsToAnalyze = [0]; % Trials to analyze (SET TO "0" TO ANALYZE ALL)

%% Plot Settings
doProbTrajPlot = false; % Plot the P-space (Not working)
doPerfPerBlockPlot = true; % Plot the performance for each adaptive block (between GT changes)
doPerfOverTimePlot = false; % Should the combined frequency over time plots be produced for this unit pair?
doTracesPlot = true; % Should the percentage traces plot be produced for this neuron pair?
doCompareTracesPlot = true; % Should the traces be compared across the duration of the trial?
doOverviewPlot = false; % Should the overview (All, [A], [B], and results from each slot in the sequence) be plotted?
saveFigsPicType = 'png'; % = 'eps; % = 'png'; % The file extension of the pictures to save as

% Performance over block modifiers (only plotted if doPerfPerBlockPlot =
% true)
doCompareToOptimal = false; % Should the results be compared to the expected performance of optimal control, assuming that the online calculated thetas are correct
doMarginalIndicator = true; % Should an indicator be placed on the side of the plot to indicate the mean response fraction over the entire penetration?

doPlotPower = true; % Should the power of stimulation be plotted per block, in addition to the strength/duration?
doPlotRfVsDeviance = true; % Should the result fraction be plotted as a function of deviance of the strengths/powers/whatever from the median strength/power/whatever
doPlotRFDifference = true; % Should the difference between TP and FA for each stimulation be plotted per block? Also plots the "state-space" probability (P1A-P2A vs P1B-P2B)
doPerfInGTHeatmap = true; % Should the performance of each block be used to build a heatmap in GT space?

% Performance over time modifiers (only plotted if doCostOverTimePlot =
% true)
doCostOverTimePlot = true; % Should the costs be plotted for each neuron?
doEpochResultsPlot = false; % Should the epoch results (cost for each search point in each epoch) be calculated?
useFilteredTraces = true; % Should the filtered trace be plotted (instead of the raw trace)?
timeBoundAll = [30]; % The time boundary for this experiment day (a vector of the max time in ms after stimulus onset to look for spikes)
numRunsPerCompareSegment = 4; % The number of Runs to include in each CompareTraces segment

% Trace plot modifiers
alignChannel = 1; % Which channel should the non-spike aligned traces align on?
findMaxRadius = 40; % The radius (in samples) around each pca code that we will look for a spike peak to align to

% Section selection
useSection = false; % Should the user pick out a section, or should the entire plot be used?
doTrimmedPerfOverTimePlot = false; % Should the trimmed (only for the selected times) combined frequency over time plots be produced for this unit pair?
useGInput = false; % Should the user pick the section times using the GUI/plot?
userTimeStart = 0; % Time in seconds when the section chosen section starts
userTimeEnd = Inf; % Time in seconds when the section chosen section ends

% Other options
useTimeXAxis = false; % Should time be used as the x-axis? (alternative: use sequence number or block number as the x-axis)
useStErr = true; % Should standard error be used (alternative: use standard deviation)?
readAnyMatName = false; % Should any .mat file name be accepted to be read (useful for load re-exported old TDT_Control files)?

% numStimsPerMainPoint = 20; % Number of stimulations per main point (detailed in next line), used for counting the number of stimulations per recalibration epoch
% numMainPointsPerNeuron = 4; % Center, center, search up, search down
% numStimsPerAltPoint = 5; % Number of stimulation per alternative point (detailed in next line), used for counting the number of stimulations per recalibration epoch
% numAltPointsPerNeuron = 3; % Escape up, escape down, verification
% smoothingSize = 21; % Number of sequences to smooth across (will calculate probabilities for this number of sequences in a boxcar smoothing manner)
sizeAdaptationBlock = 10; % Number of sequences per adaptation block
smoothingSize = 20; % Number of stimuli to smooth across (will calculate probabilities for this number of stimulations in a boxcar smoothing manner)
maxTimeRecorded = 50; % Number of milliseconds that are recorded for each trace
lengthWaveformPart = 20; % Number of milliseconds after the onset of stimulation to display in the waveforms
adaptivePOTLoc1 = 1.2; % The y-axis location that G1 changes should be indicated at
adaptivePOTLoc2 = 1.1; % The y-axis location that G2 changes should be indicated at
alignedTraceLimits = [-1 2]; % The x-axis limits for aligned traces
sizeData = 1000; % Number of samples recorded
pcaCodeDelay = 3.3; % The delay between a spike and its pca code being registered (due to real-time constraints)
gtHeatmapResolution = 50; % Total number of "cells" to include in each dimension for the heatmap
gtHeatmapKernelSize = 25; % Diameter of the kernel used to indicate the performance of each trial
plotFontSize = 24;
plotSmallFontSize = 16;
legendFontSize = 12;
strengthFontSize = 12;
adaptiveGTFontSize = 16;
adaptiveGTMarkerSize = 10;
plotLineWidth = 2;
markerSize = 15;
ordersMarkerSize = 10;
ordersLineWidth = 2;
ordersFontSize = 16;

gauss2DFcn = @(size) exp(-(((((0:(size - 1)) - ((size - 1)/2)).^2)/(2*(size/6))) + ((((0:(size - 1))' - ((size - 1)/2)).^2)/(2*(size/6)))));

% Set up strings for plotting
numMarkers = 100; % Number of markers to display (purely for asthetic purposes, to defeat overcrowding)
% if savingExampleFigures
TP1LineStr = 'b-';
TP2LineStr = 'r-';
FA1LineStr = 'b:';
FA2LineStr = 'r:';

TP1MarkStr = 'bx';
TP2MarkStr = 'ro';
FA1MarkStr = 'bo';
FA2MarkStr = 'rx';

TP1CombStr = 'bx-';
TP2CombStr = 'ro-';
FA1CombStr = 'bo:';
FA2CombStr = 'rx:';

% Required file for approximating firing probability
FPDataFile = 'logisticFPTable.mat';
saveFigBase = 'D:\samuelgb\Documents\MATLAB\Acute Control\';
saveFigSubDir = ['Figures' filesep 'Silicon Probe Data'];
exampleDir = ['Figures' filesep 'Example Figure Directory'];
dataDirBase = 'D:\samuelgb\Documents\MATLAB\Acute Control\Data\Silicon Probe Data\';
analysisDataDir = 'AnalysisData'; % (Added 2/15/18) This directory will be placed inside of each "data directory", and will contain the analysis results of each INDIVIDUAL experiment date, so that across-date analysis can then be performed.
analysisDataFileBase = 'analysis_';

if savingExampleFigures
    saveFigDir = [saveFigBase exampleDir];
    if exist(saveFigDir, 'dir')
        rmdir(saveFigDir, 's');
    end
else
    saveFigDir = [saveFigBase saveFigSubDir];
end
% File names for different bugs which may exist in the acquisition code,
% which can be corrected
repeatRunBugBaseFileName = 'BUG_REPEAT_RUN.txt';
fifthStimBugBaseFileName = 'BUG_FIFTH_STIM.txt';

% adaptiveCostFunction = @(avgProb1, avgProb2) (1/3)*(1 + avgProb2 - avgProb1 + (1 - avgProb1).^2);
costFunLambda = 1e-5; %.01;
adaptiveCostFunction = @(P1, P2, G) -(P1 .* (1 - P2)) + costFunLambda*(G.^2); % Cost function to optimize using control

%% Prepare needed information
% Define helper functions
fractionOfTotal = @(mat) sum(logical(mat(:)))/numel(mat); % This function gets the percentage of logical true's in a 2D matrix
cellMean = @(a) cell2mat(cellfun(@mean, a, 'uniformoutput', false));
cellSTD = @(a) cell2mat(cellfun(@std, a, 'uniformoutput', false));
quartEq = @(x, a, b, c, d) x.^4.*a + x.^3.*b + x.^2.*c + x.*d;

% Calculate size of smoothing window
% trueSmoothingRadius = floor(smoothingSize/2);
% trueSmoothingDiameter = 2*trueSmoothingRadius;

% Conversion factor to turn the trace units to microvolts (they are in
% 1e-4V, or 1e2µV, now)
convToMicroV = 100;

numLengths = 1; % Number of stim order lengths (Just [], [A], and [B])
numStimOrdersAll = sum(2.^(0:numLengths)); % Number of previous stim orders (numUnits subtracted because the previous stim orders of "AAA" and "BBB" should not be considered, as they have more of a single stim-type than is allowed), plus 1 because blank stim order is included.
numCases = 4; % Number of cases (2 neurons x 2 probabilities in the confusion matrix [true positive, false positive])
numChansPerTet = 4; % Number of channels per tetrode

% if ~doCompareTracesPlot
%     numCompareSegments = 1; % If the traces are not being compared, then make the trial only one segment
% end

if generateAnalysisData
    % If the run's only purpose is to save all basic data to file, the
    % specific analysis needed for each figure will not be done.
    saveFigs = false;
    analyzeOnline = true;
    analyzeOffline = true;
end

%% Load all files that are desired
[allMatStruct, timeStrings, dateStrings] = loadTrialData(true(1,2), readAnyMatName, dirsToRead); % "true" makes loadTrialData load both online and offline data (even if it isn't going to be used), mostly because the EpochResults plot requires information from both
numFiles = size(allMatStruct, 1);

someOffline = size(allMatStruct,3) > 1; % Are there any offline sorts for this date?
% if doTracesPlot || generateAnalysisData
if (length(timeBoundAll) > 1)
    if length(timeBoundAll) ~= numFiles
        error('Incorrect size of timeBoundAll (should be one time bound for each file being analyzed).');
    end
else
    timeBoundAll = repmat(timeBoundAll,1,numFiles);
end
% end

if all(all(cell2mat(cellfun(@isempty, allMatStruct, 'uniformoutput', false))))
    fprintf('No data found.  Ending script.\n');
    return;
end
fprintf('All data loaded.  Starting analysis...\n\n');

% if doTracesPlot || generateAnalysisData
% If making a trace plot, make sure that each date is only loaded once
% Check if any data is currently loaded
if exist('expDateStr', 'var')
    curDateStrLoaded = expDateStr;
else
    curDateStrLoaded = '';
end
% end

%% Loop through all unit pairs
for fileNumInd = 1:numFiles
    thisUseFifthStimBugCorrection = useFifthStimBugCorrectionIfNeeded;
    thisUseRepeatRunBugCorrection = useRepeatRunBugCorrectionIfNeeded;
    thisDoTracesPlot = doTracesPlot;
    thisDoCompareTracesPlot = doCompareTracesPlot;
    thisGenerateAnalysisData = generateAnalysisData;
    
    %% Check if file should be skipped
    hasOnlineSort = ~isempty(allMatStruct{fileNumInd, 1, 1});
    
    % Check if this file has offline sorting
    % Make sure that the allMatStruct has a third dimension higher than 1, otherwise an error will occur
    hasOfflineSort = someOffline && ~isempty(allMatStruct{fileNumInd, 1, 2}); % If this slot is not empty, it contains the neuronstruct from the offline sort
    
    dateStr = dateStrings{fileNumInd};
    timeStr = timeStrings{fileNumInd};
    %     try
    for sortInd = 1:2
        %% Go through each sorting (online or offline) for this file
        switch sortInd
            case 1
                if ~(analyzeOnline && hasOnlineSort)
                    continue;
                end
                sortStr = 'Online';
                shortenedStr = 'On';
                
                thisPCACodeDelay = pcaCodeDelay; % Add a delay between PCA codes and spikes
            case 2
                if ~(analyzeOffline && hasOfflineSort)
                    continue;
                end
                sortStr = 'Offline';
                shortenedStr = 'Off';
                
                thisPCACodeDelay = 0; % Do not add a delay between PCA codes and spikes
        end
        % Load data, if it isn't empty
        N1 = allMatStruct{fileNumInd, 1, sortInd};
        N2 = allMatStruct{fileNumInd, 2, sortInd};
        
        didTrial = false;
        usePCA = false;
        try
            if ~isempty(N1.pcaSortCodes{1}) && ~isempty(N2.pcaSortCodes{1}) % If it exists, no error will be thrown
                usePCA = true;
            end
            
            trialsCompleted = false(1, length(N1.trialData));
            for i = 1:length(N1.trialData)
                if N1.trialData(i).trialCompleted
                    didTrial = true;
                    trialsCompleted(i) = true;
                end
            end
        end
        
        if didTrial && usePCA
            trialInds = find(trialsCompleted);
            numTrials = length(trialInds);
        else
            continue; % Skip this unit
        end
        
        %% Create directories if needed
        if thisGenerateAnalysisData
            thisAnalysisDataDir = [dataDirBase dateStr filesep analysisDataDir];
            if ~exist(thisAnalysisDataDir, 'dir')
                mkdir(thisAnalysisDataDir);
            end
        end
        
        if saveFigs
            if savingExampleFigures
                saveFigDirPath = [saveFigDir filesep sortStr filesep];
            else
                saveFigDirPath = [saveFigDir filesep sortStr filesep dateStr filesep timeStr filesep];
            end
            if ~exist(saveFigDirPath, 'dir')
                mkdir(saveFigDirPath);
            end
            
            if savingExampleFigures
                if thisDoTracesPlot
                    saveFigTracesPath = saveFigDirPath;
                end
                
                if doProbTrajPlot
                    saveFigProbTraj = saveFigDirPath;
                end
                
                if doPerfOverTimePlot
                    saveFigPerfOverTimePath = saveFigDirPath;
                end
                
                if doPerfPerBlockPlot
                    saveFigPerfPerBlockPath = saveFigDirPath;
                end
                
                if doTrimmedPerfOverTimePlot
                    saveFigTrimmedPerfOverTimePath = saveFigDirPath;
                end
                
                if doOverviewPlot
                    saveFigOverviewPath = saveFigDirPath;
                end
                
                if thisDoCompareTracesPlot
                    saveFigCompareTracesPath = saveFigDirPath;
                end
            else
                if thisDoTracesPlot
                    saveFigTracesPath = [saveFigDirPath 'Traces' filesep ];
                    if ~exist(saveFigTracesPath, 'dir')
                        mkdir(saveFigTracesPath);
                    end
                end
                
                if doProbTrajPlot
                    saveFigProbTraj = [saveFigDirPath 'ProbTraj' filesep];
                    if ~exist(saveFigProbTraj, 'dir')
                        mkdir(saveFigProbTraj);
                    end
                end
                
                if doPerfOverTimePlot
                    saveFigPerfOverTimePath = [saveFigDirPath 'PerfOverTime' filesep];
                    if ~exist(saveFigPerfOverTimePath, 'dir')
                        mkdir(saveFigPerfOverTimePath);
                    end
                end
                
                if doPerfPerBlockPlot
                    saveFigPerfPerBlockPath = [saveFigDirPath 'PerfPerBlock' filesep];
                    if ~exist(saveFigPerfPerBlockPath, 'dir')
                        mkdir(saveFigPerfPerBlockPath);
                    end
                end
                
                if doTrimmedPerfOverTimePlot
                    saveFigTrimmedPerfOverTimePath = [saveFigDirPath 'TrimmedPerfOverTime' filesep];
                    if ~exist(saveFigTrimmedPerfOverTimePath, 'dir')
                        mkdir(saveFigTrimmedPerfOverTimePath);
                    end
                end
                
                if doOverviewPlot
                    saveFigOverviewPath = [saveFigDirPath 'Overview' filesep];
                    if ~exist(saveFigOverviewPath, 'dir')
                        mkdir(saveFigOverviewPath);
                    end
                end
                
                if thisDoCompareTracesPlot
                    saveFigCompareTracesPath = [saveFigDirPath 'CompareTraces' filesep];
                    if ~exist(saveFigCompareTracesPath, 'dir')
                        mkdir(saveFigCompareTracesPath);
                    end
                end
            end
        end
        
        %% Determine which known bugs influenced this data
        % Generate the names of the manually added files which would
        % indicate the existance of these known bugs
        thisRepeatRunBugFileName = sprintf('%s%s%s%s', dataDirBase, dateStr, filesep, repeatRunBugBaseFileName);
        thisFifthStimBugFileName = sprintf('%s%s%s%s', dataDirBase, dateStr, filesep, fifthStimBugBaseFileName);
        
        % If the files exist, and we want to use the correction, then set
        % the flag to perform the correction
        thisUseRepeatRunBugCorrection = thisUseRepeatRunBugCorrection && exist(thisRepeatRunBugFileName, 'file');
        thisUseFifthStimBugCorrection = thisUseFifthStimBugCorrection && exist(thisFifthStimBugFileName, 'file');
        
        %% Load data
        % Check if the traces information is needed, if it's been loaded,
        % and/or if it still needs to be processed
        % Get information from the expStimResponses variable!
        doTracesLoad = false;
        if thisDoTracesPlot || thisDoCompareTracesPlot
            haveData = false;
            % First, see if the variable is already in the workspace
            if evalin('base', 'exist(''expStimResponses'', ''var'')')
                haveData = true;
            else
                if exist('convertNTTResults.mat', 'file')
                    % If the results file exists, which most likely has the
                    % required data
                    
                else
                    
                end
            end
            
            if haveData
                % If the data is in the workspace, either from being there
                % already or from freshly loading a file
                expStimResponses = evalin('base', 'expStimResponses');
                expTetNums = evalin('base', 'expTetNums');
            end
        end
        
        numUnits = size(allMatStruct, 2);
        resultsData1 = N1.resultsData;
        resultsData2 = N2.resultsData;
        resultsTimes1 = resultsData1(:,4); % When was this stimulation done?
        resultsTimes2 = resultsData2(:,4);
        stimResultsAll1 = resultsData1(:,3); % Did the unit spike after the stimulation?
        stimResultsAll2 = resultsData2(:,3);
        trueLStrengths = [];
        
        % Figure out the TDT tank information
        if thisDoTracesPlot || thisDoCompareTracesPlot || thisGenerateAnalysisData || thisUseFifthStimBugCorrection || thisUseRepeatRunBugCorrection
            % See if we really need to load the data in or not
            someDataLoaded = true;
            
            % Check if the data is in the base workspace
            if ~strcmp(curDateStrLoaded, dateStr)
                % The data is not already loaded in the workspace
                % Next, see if the file that has the data exists
                resultsFileName = sprintf('%s%s%sconvertNTTResults.mat', dataDirBase, dateStr, filesep);
                if exist(resultsFileName, 'file')
                    % If the file exists, simply load into THIS workspace
                    % and continue on our way
                    load(resultsFileName);
                else
                    % If the file does not exist, try making the file
                    try
                        makeNTT = ~exist(sprintf('%s%s%s%s_%s_A.ntt', dataDirBase, dateStr, filesep, dateStr, timeStr), 'file'); % If no NTT files exist, make them now (because it takes so damn long to do so); otherwise, don't overwrite old ones
                        convertTankToNTT_silicon(dateStr, makeNTT, 30, timeBoundAll(fileNumInd), true); % Load the data into the base workspace
                        
                        expTankNums = evalin('base', 'expTankNums');
                        expTimeStrs = evalin('base', 'expTimeStrs');
                        expTimeBounds = evalin('base', 'expTimeBounds');
                        expPenetrationNums = evalin('base', 'expPenetrationNums');
                        expStimResponses = evalin('base', 'expStimResponses');
                        expTetNums = evalin('base', 'expTetNums');
                    catch
                        % Data file not found, and we failed at trying to
                        % make it...oh well!
                        someDataLoaded = false;
                    end
                end
            else
                % Data is currently loaded
            end
            
            % By now, the data should be loaded, so continue preparing
            properDataLoaded = true;
            if someDataLoaded
                try
                curDateStrLoaded = dateStr;
                thisTimeInd = find(cell2mat(cellfun(@(a) strcmp(timeStr, a), expTimeStrs, 'uniformoutput', false))); % The index in expTankNums that represents this experiment
                thisInterval = expTimeBounds(thisTimeInd, :);
                thisDataTankNum = expTankNums(thisTimeInd);
                thisStimResponses = expStimResponses{thisTimeInd};
                thisTetNums = expTetNums(thisTimeInd, :);
                dateTankNumCombo = sprintf('Acute_%s_%0.2d', dateStr, thisDataTankNum);
                tdtBlockLoc = sprintf('%s%s%s%s\\TutTank_%s.tsq', dataDirBase, dateStr, filesep, dateTankNumCombo, dateTankNumCombo);
                catch
                    % It turns out that the data we loaded is not actually
                    % good
                    properDataLoaded = false;
                end
            end
            
            if ~properDataLoaded
                % If, after all that, we couldn't load the data, then shut
                % down some functions and warn the user
                thisUseFifthStimBugCorrection = false;
                thisUseRepeatRunBugCorrection = false;
                thisDoTracesPlot = false;
                thisDoCompareTracesPlot = false;
                thisGenerateAnalysisData = false;
                
                fprintf('\n\n**********\n**********\nWarning %s_%s: Could not load data from tank/convert tank to NTT file.  Not able to use bug corrections, plot traces, or generate analysis data.\n**********\n**********\n\n\n', dateStr, timeStr);
            end
        end
        
        % The only information needed from the tank is the laser pulse
        % strengths, but the correct tank must be found for each trial
        % TODO: FIX THIS; USE THE LASER EQUATION DATA FROM THE
        % lasEqVals_.mat FILE
        if (thisDoTracesPlot || thisGenerateAnalysisData) && ~strcmp(curDateStrLoaded, dateStr)
            % Open the tank for reading information
            block = tdt_block_sam(tdtBlockLoc);
            
            trueLStrengths = nan(numTrials, numUnits); % The data needed at the end of this
            
            % Load laser strengths from the tank
            if numTrials ~= length(expPenetrationNums(thisTimeInd,:))
                error('TDT data includes %d trials, while .mat data includes %d trials.\n', length(expPenetrationNums(thisTimeInd,:)), numTrials);
            end
            pNums = getdata(block, 'TDat', 'channel', 4, 'interval', thisInterval);
            eRs = getdata(block, 'TDat', 'channel', 5, 'interval', thisInterval);
            lStrengths = getdata(block, 'TDat', 'channel', 6, 'interval', thisInterval);
            [~, pNumFirstStimInd] = ismember(expPenetrationNums(thisTimeInd,:), pNums.vals);
            
            eRIndsOfUnitStim = zeros(numTrials, numUnits);
            for trialNum = 1:numTrials
                eRIndsOfUnitStim(trialNum, 1) = find(eRs.vals(pNumFirstStimInd(trialNum):end) == 0, 1) + pNumFirstStimInd(trialNum) - 1; % Find the first index in eRs (after pNumFirstStimInd(trialNum) that represents a unit A stimulation
                eRIndsOfUnitStim(trialNum, 2) = find(eRs.vals(pNumFirstStimInd(trialNum):end) == 1, 1) + pNumFirstStimInd(trialNum) - 1; % Find the first index in eRs (after pNumFirstStimInd(trialNum) that represents a unit B stimulation
            end
            
            rawLStrengths = lStrengths.vals(eRIndsOfUnitStim);
            
            % Load laser parameters
            ready = true;
            lAStruct = getdata(block, 'LSet', 'channel', 1, 'interval', thisInterval);
            lBStruct = getdata(block, 'LSet', 'channel', 2, 'interval', thisInterval);
            lCStruct = getdata(block, 'LSet', 'channel', 3, 'interval', thisInterval);
            lDStruct = getdata(block, 'LSet', 'channel', 4, 'interval', thisInterval);
            
            if ((lAStruct.vals(1) - .1) < 1e-4)
                fprintf('This TDT block did not have usable laser strengths, searching through neighboring blocks...\n');
                cd([dataPath filesep dateStr]); % Move to this date's directory
                ready = false;
                tankPrefix = sprintf('Acute_%s', dateStr);
                dataDirContents = dir;
                for i = 1:length(dataDirContents)
                    tankName = dataDirContents(i).name;
                    if (length(tankName) > length(tankPrefix)) && strcmp(tankName(1:length(tankPrefix)), tankPrefix)
                        % If this data is a tank, check its tank number to make
                        % sure the same one doesn't get loaded multiple times
                        fileParts = strsplit(tankName, '_');
                        thisDirTankNum = str2double(fileParts{3});
                        if (thisDirTankNum == thisDataTankNum)
                            % The tank being looked at right now is the same
                            % one that this data is in; if it had data, we
                            % wouldn't be in this loop looking for the laser
                            % data (then again, if TDT just worked properly in
                            % the first place, we wouldn't be here either...)
                            continue;
                        end
                        
                        % If this directory is a tank, extract and test the data
                        tsqFileName = sprintf('TutTank_%s.tsq', tankName);
                        thisBlock = tdt_block_sam(tsqFileName);
                        
                        try
                            testA = getdata(thisBlock, 'LSet', 'channel', 1);
                        catch
                            continue;
                        end
                        
                        if abs(testA.vals(1) - .1) > 1e-4
                            lAStruct = testA;
                            lBStruct = getdata(thisBlock, 'LSet', 'channel', 2, 'interval', thisInterval);
                            lCStruct = getdata(thisBlock, 'LSet', 'channel', 3, 'interval', thisInterval);
                            lDStruct = getdata(thisBlock, 'LSet', 'channel', 4, 'interval', thisInterval);
                            
                            ready = true;
                        else
                            continue;
                        end
                    end
                    
                end
            end
            
            if ready
                lA = repmat(lAStruct.vals(1), numTrials, numUnits);
                lB = repmat(lBStruct.vals(1), numTrials, numUnits);
                lC = repmat(lCStruct.vals(1), numTrials, numUnits);
                lD = repmat(lDStruct.vals(1), numTrials, numUnits);
                
                trueLStrengths = quartEq(rawLStrengths, lA, lB, lC, lD);
            end
        end
        
        %% Loop through all trials
        for trialIndsInd = 1:numTrials
            trialNum = trialInds(trialIndsInd);
            if ~any(trialsToAnalyze == trialNum) && ~any(trialsToAnalyze == 0)
                continue; % If this trial number doesn't appear in trialsToAnalyze, and trialsToAnalyze isn't set to 0, skip this trial
            end
            if useGInput
                close all;
            end
            %% Prepare for the analysis
            runOrdersT = N1.trialData(trialNum).runOrders'; % The order of the sequences in each run
            stimTimes1 = N1.trialData(trialNum).stimTimes; % The times of each stimulation
            stimTimes2 = N2.trialData(trialNum).stimTimes;
            indsInResultsData1 = N1.trialData(trialNum).stimInds;
            indsInResultsData2 = N2.trialData(trialNum).stimInds;
            eRSingle1 = N1.trialData(trialNum).expectedResults; % Expected results in the order of the actual stimulations
            eRSingle2 = N2.trialData(trialNum).expectedResults;
            iS = N1.trialData(trialNum).interStimPeriod; % The inter-spike intervals from each sequence (in the "standard" order, before the runOrder is applied)
            
            numStimsPerSequence = N1.trialData(trialNum).numStimsPerSequence; % Number of slots per sequence
            numSequences = size(stimTimes1,1); % Total number of sequences in this trial
            numRuns = size(runOrdersT, 2); % Number of runs in the trial
            numSequencesPerRun = size(runOrdersT, 1); % Number of sequences per run
            numAllStims = numStimsPerSequence*numSequences;
            adjustedStimTimes = (stimTimes1 - stimTimes1(1,1))/60; % Times that stimulations occurred, in minutes, relative to the first stim time
            adjustedStimTimesT = adjustedStimTimes';
            adjustedStimTimesCol = adjustedStimTimesT(:);
            adjustedSequenceTimes = (stimTimes1(:,1)' - stimTimes1(1,1))/60; % Times that sequences started, in minutes, relative to the first stim time
            %         thisTrueSmoothingDiameter = min(trueSmoothingDiameter, numSequences); % Adjust the smoothing size as needed
            
            seqInfoInds1 = find(N1.sequenceInfo(:,1) == stimTimes1(1)) + (0:(numSequences - 1));
            seqInfoInds2 = find(N2.sequenceInfo(:,1) == stimTimes2(1)) + (0:(numSequences - 1));
            
            % Use the TDT data to get the stimulation results
            if thisUseFifthStimBugCorrection
                %% Load the TDT data
                %                 block = tdt_block_sam(tdtBlockLoc);
                %
                %                 % Get the times to load
                %                 pNum = getdata(block, 'TDat', 'channel', 4);
                %                 relevantStimInds = find(pNum.vals == penNums(1), length(stimTimes1), 'last');
                %                 stimTimeStamps = pNum.times(relevantStimInds);
                %                 timeBounds = [stimTimeStamps(1) (stimTimeStamps(end) + 1)]; % Get the beginning and end times of the experiment (add to the end time, because it indicates the stim time, the neural response takes longer to develop)
                %
                %                 probeA = getdata(block, 'Raw1', 'channel', 1, 'interval', timeBounds); % Get the filtered data for probe 1
                %                 probeB = getdata(block, 'Raw1', 'channel', 2, 'interval', timeBounds); % Get the filtered data for probe 1
                %                 sortCodesA = getdata(block, 'Raw1', 'channel', 5, 'interval', timeBounds); % Get the filtered data for probe 1
                %                 sortCodesB = getdata(block, 'Raw1', 'channel', 6, 'interval', timeBounds); % Get the filtered data for probe 1
                %
                %                 % Get all waveforms
                %                 wvA = probeA.vals*convToMicroV;
                %                 wvB = probeB.vals*convToMicroV;
                %
                %                 % Find where spikes occurred
                %                 crossIndsA = sortCodesA.vals == 1;
                %                 crossIndsB = sortCodesB.vals == 1;
                %                 pcaAdjust = -.0025;
                %                 spikeTimeStampsA = fullProbeA.times(crossIndsA) + pcaAdjust;
                %                 spikeTimeStampsB = fullProbeB.times(crossIndsB) + pcaAdjust;
                %
                %                 [~, binNumsA] = histc(spikeTimeStampsA, binEdgesA); % Find where each stimulus is
                %                 [~, binNumsB] = histc(spikeTimeStampsB, binEdgesB); % Find where each stimulus is
                %                 binNumsA(binNumsA == 0) = max(binNumsA);
                %                 binNumsB(binNumsB == 0) = max(binNumsB);
                %                 binNumsA(mod(binNumsA,2) == 0) = binNumsA(mod(binNumsA,2) == 0) - 1;
                %                 binNumsB(mod(binNumsB,2) == 0) = binNumsB(mod(binNumsB,2) == 0) - 1;
                %
                %                 stimNumsA = ceil(binNumsA/2); % Get the stimulation number for each spike
                %                 stimNumsB = ceil(binNumsB/2); % Get the stimulation number for each spike
                %
                %                 % Find the delay of each spike within the waveform
                %                 spikeDelayA = (spikeTimeStampsA - binEdgesA(binNumsA))*1000; % The start of the small range in which the maximum of a spike should be found
                %                 spikeDelayB = (spikeTimeStampsB - binEdgesB(binNumsB))*1000;
                
                % Get the spike delay and stim number for each spike,
                % evaluated in convertTankToNSE_adaptive
                spikeDelayA = evalin('base', sprintf('spikeDelay_%s_A', timeStr));
                spikeDelayB = evalin('base', sprintf('spikeDelay_%s_B', timeStr));
                
                stimNumsA = evalin('base', sprintf('stimNums_%s_A', timeStr));
                stimNumsB = evalin('base', sprintf('stimNums_%s_B', timeStr));
                
                keepIndsA = spikeDelayA <= timeBoundAll(fileNumInd); % Figure out which spikes matter
                keepIndsB = spikeDelayB <= timeBoundAll(fileNumInd);
                
                spikeDelayA = spikeDelayA(keepIndsA);
                spikeDelayB = spikeDelayB(keepIndsB);
                stimNumsA = stimNumsA(keepIndsA);
                stimNumsB = stimNumsB(keepIndsB);
                
                % Preallocate a properly size array for the results
                sRCol1 = false(numel(stimTimes1), 1);
                sRCol2 = false(numel(stimTimes2), 1);
                
                % Calculate the results of the stimulations
                positiveResultsInds1 = unique(stimNumsA);
                positiveResultsInds2 = unique(stimNumsB);
                
                sRCol1(positiveResultsInds1) = true;
                sRCol2(positiveResultsInds2) = true;
            else
                stimResultsThisTrial1 = logical(stimResultsAll1(indsInResultsData1)); % Results of the stimulations in the trial
                stimResultsThisTrial2 = logical(stimResultsAll2(indsInResultsData2));
                
                stimResultsT1 = stimResultsThisTrial1';
                sRCol1 = stimResultsT1(:);
                stimResultsT2 = stimResultsThisTrial2';
                sRCol2 = stimResultsT2(:);
            end
            
            inds1T = indsInResultsData1';
            inds1 = inds1T(:);
            inds2T = indsInResultsData2';
            inds2 = inds2T(:);
            
            thisTrialResultsData1 = resultsData1(inds1,:);
            thisTrialResultsData2 = resultsData2(inds2,:);
            
            vT1 = N1.voltageTraces(inds1); % Get the voltage traces data, specifically for the analyzeAllExperiments script
            vT2 = N2.voltageTraces(inds2);
            
            %             stimStrengthsThisTrialT = stimStrengthsAll(indsInResultsData1)';
            %             stimStrengthsThisTrial = stimStrengthsThisTrialT(:); % Strengths used to stimulate both neurons in this trial
            
            % Determine the expected results of this entire trial
            eRMatlabAll1 = eRSingle1(runOrdersT(:), :); % The expected results that the neuron will have for each sequence
            eRMatlabAll2 = eRSingle2(runOrdersT(:), :); % --This should be the same as ~eR1--
            
            eRMatlabAll1T = eRMatlabAll1';
            eRMatlabAll1Col = eRMatlabAll1T(:);
            eRMatlabAll2T = eRMatlabAll2';
            eRMatlabAll2Col = eRMatlabAll2T(:);
            
            if thisUseRepeatRunBugCorrection
                % If this data had the third block bug
                block = tdt_block_sam(tdtBlockLoc);
                
                laserEqFile = sprintf('%s%s%slasEqVals%s.mat', dataDirBase, dateStr, filesep, dateStr);
                
                % Repeat the first run's ER continuously for the entire
                % experiment
                numStimsPerRun = numStimsPerSequence*numSequencesPerRun;
                numRuns = size(runOrdersT, 2);
                eRAll1 = repmat(eRMatlabAll1(1:numSequencesPerRun, :), numRuns, 1);
                eRAll2 = repmat(eRMatlabAll2(1:numSequencesPerRun, :), numRuns, 1);
                eRAll1Col = repmat(eRMatlabAll1Col(1:numStimsPerRun), numRuns, 1);
                eRAll2Col = repmat(eRMatlabAll2Col(1:numStimsPerRun), numRuns, 1);
                
                % Extract the GT pairs from the TDT block
                maxDur = 15; % The maximum duration in ms
                laserRadius = .1; % Radius of wave guide in mm
                powToIrr = 1/((laserRadius^2)*pi*1000); % The factor by which to multiply the fiber power in µW (the laser parameters cubic equation converts the control voltage to µW) to get irradiance in mW/mm^2 (calculated by dividing the power by the area of the fiber)
                lShutter = getdata(block, 'Lasr', 'channel', 1, 'interval', thisInterval);
                lStrs = getdata(block, 'Lasr', 'channel', 3, 'interval', thisInterval);
                onsetInds = diff(lShutter.vals) > 0;
                
                if sum(onsetInds) ~= length(eRMatlabAll1Col)
                    fprintf('***************\n\nBad shutter data from %s_%s\nSkipping\n\n***************', dateStr, timeStr);
                    continue;
                end
                
                offsetTimes = lShutter.times(diff(lShutter.vals) < 0);
                onsetTimes = lShutter.times(onsetInds);
                sDursCol = max(min((offsetTimes - onsetTimes)*1000, maxDur), 0); % Convert from seconds to milliseconds
                
                allStrsV = lStrs.vals(onsetInds);
                
                % Convert the strengths to irradiances
                % Load the laser equation .mat file
                if exist(laserEqFile, 'file')
                    load(laserEqFile)
                    laserEq = [a b c d];
                else
                    % Well...do with what we have, I suppose...
                    laserEq = N1.laserEQ;
                end
                
                % Convert the control voltages to irradiances
                sStrsCol = max(powToIrr*polyval(laserEq, allStrsV), 0);
                
                stimStrengthsThisTrialT = zeros(numStimsPerSequence, numSequences);
                stimDurationsThisTrialT = zeros(numStimsPerSequence, numSequences);
                
                stimStrengthsThisTrialT(:) = sStrsCol;
                stimStrengthsThisTrial = stimStrengthsThisTrialT';
                stimDurationsThisTrialT(:) = sDursCol;
                stimDurationsThisTrial = stimDurationsThisTrialT';
            else
                eRAll1 = eRMatlabAll1;
                eRAll2 = eRMatlabAll2;
                eRAll1Col = eRMatlabAll1Col;
                eRAll2Col = eRMatlabAll2Col;
                
                stimStrengthsAll = resultsData1(:,1);
                stimDurationsAll = resultsData1(:,2);
                stimStrengthsThisTrial = stimStrengthsAll(indsInResultsData1);
                stimDurationsThisTrial = stimDurationsAll(indsInResultsData1);
                
                sStrsT = stimStrengthsThisTrial';
                sStrsCol = sStrsT(:);
                sDursT = stimDurationsThisTrial';
                sDursCol = sDursT(:);
            end
            
            % Extract the stim strengths and durations from each neuronStruct
            allG1 = N1.sequenceInfo(seqInfoInds1,end - 2); % Strength to activate A
            allT1 = N1.sequenceInfo(seqInfoInds1,end - 1); % Duration to activate A
            allG2 = N2.sequenceInfo(seqInfoInds2,end - 2); % Strengths to activate B
            allT2 = N2.sequenceInfo(seqInfoInds2,end - 1); % Duration to activate B
            
            % Extract the parameters
            parameters1All = N1.parameters;
            parameters2All = N2.parameters;
            optInds1 = N1.trialData(trialNum).opt;
            optInds2 = N2.trialData(trialNum).opt;
            
            % Get the parameters that were calculated before the trial
            % started (if one was calculated...which is damn well should
            % have been...)
            if length(optInds1) == numAllStims/(sizeAdaptationBlock*numStimsPerSequence)
                % Hopefully just a temporary hack to make the sequential
                % adaptation blocks work (it maybe makes sense?)
                parameters1 = parameters1All(optInds1, :);
                parameters2 = parameters2All(optInds2, :);
                
                optInds1 = optInds1 - 1;
                optInds2 = optInds2 - 1;
            else
                if (optInds1(1) > 1)
                    optInds1 = [(optInds1(1) - 1); optInds1];
                end
                
                if (optInds2(1) > 1)
                    optInds2 = [(optInds2(1) - 1); optInds2];
                end
                
                parameters1 = parameters1All(optInds1, :);
                parameters2 = parameters2All(optInds2, :);
            end
            
            % Calculate the number of compare segments for this analysis
            if thisDoCompareTracesPlot
                numCompareSegments = ceil(numRuns/numRunsPerCompareSegment); % Number of segments to split each trial into, to compare spike shapes
            else
                numCompareSegments = 1; % No comparisons should be done, so there's just one large segment
            end
            
            %% Analyze sequence information (determine results for stimulation in sequence)
            % Preallocate variables for calculation
            numTimeSteps = numAllStims - smoothingSize + 1;
            TP1 = nan(numTimeSteps,1);
            TP2 = nan(numTimeSteps,1);
            FA1 = nan(numTimeSteps,1);
            FA2 = nan(numTimeSteps,1);
            cost1 = nan(numTimeSteps, 1);
            cost2 = nan(numTimeSteps, 1);
            
            % Calculate smoothing window
            if smoothingSize > 1
                n = 0:(smoothingSize - 1);
                %                 w = cos((pi*n)/(smoothingSize - 1) - pi/2); % Non-causal
                w = cos((pi*n)/(2*(smoothingSize - 1)) - pi/2); % Causal
                %         cosW = repmat(cosW', numSlots, 1); % Smoothing window is applied to each stim individually, but it is applied to the columnization of TPLogicalX./eRX, each of which are numSequences x numSlots, which means the column contains [seq1slot1, seq2slot1, ..., seqNslot1, seq1slot2, ...] (lists all sequences' first slot, then all sequences' second slot, etc.), so the smoothing window is repeated, because it must be applied according to each sequence, not the slot number
                w = w'/sum(w); % Normalize the window so it does not scale the data
            else
                w = 1;
            end
            
            %% Analyze the unit performance (calculate probabilities, and apply window filter)
            for timeStep = 1:numTimeSteps
                %% Extract needed information
                % Sequences that will be used in this calculation
                sequenceInds1 = find(eRAll1Col(1:(smoothingSize + timeStep - 1)), smoothingSize, 'last');
                sequenceInds2 = find(eRAll2Col(1:(smoothingSize + timeStep - 1)), smoothingSize, 'last');
                
                if length(sequenceInds1) >= smoothingSize
                    thisSR1 = sRCol1(sequenceInds1);
                    thisSR2 = sRCol2(sequenceInds1);
                    thisStrs = sStrsCol(sequenceInds1);
                    thisDurs = sDursCol(sequenceInds1);
                    thisCosts = adaptiveCostFunction(thisSR1, thisSR2, thisStrs);
                    
                    TP1(timeStep) = sum(w.*thisSR1);
                    FA2(timeStep) = sum(w.*thisSR2);
                    cost1(timeStep) = sum(w.*thisCosts);
                end
                
                if length(sequenceInds2) >= smoothingSize
                    thisSR1 = sRCol1(sequenceInds2);
                    thisSR2 = sRCol2(sequenceInds2);
                    thisStrs = sStrsCol(sequenceInds2);
                    thisDurs = sDursCol(sequenceInds2);
                    thisCosts = adaptiveCostFunction(thisSR2, thisSR1, thisStrs);
                    
                    FA1(timeStep) = sum(w.*thisSR1);
                    TP2(timeStep) = sum(w.*thisSR2);
                    cost2(timeStep) = sum(w.*thisCosts);
                end
            end
            
            TP1Avg = sum(sRCol1(logical(eRAll1Col)))/sum(eRAll1Col);
            FA1Avg = sum(sRCol1(logical(eRAll2Col)))/sum(eRAll2Col);
            TP2Avg = sum(sRCol2(logical(eRAll2Col)))/sum(eRAll2Col);
            FA2Avg = sum(sRCol2(logical(eRAll1Col)))/sum(eRAll1Col);
            
            %% Prepare for plotting
            % Create a time-axis for plotting
            % sequenceTimeInds = (floor(smoothingSize/2) + 1):(floor(smoothingSize/2) + numTimeSteps); % Non-causal
            %             sequenceTimeInds = smoothingSize:(smoothingSize + numTimeSteps - 1); % Causal
            %
            %             if useTimeXAxis
            %                 potXAxis = adjustedSequenceTimes(sequenceTimeInds); % Get the times of each sequence firing (use the time of the sequence at the center of the smoothing window)
            %             else
            %                 potXAxis = sequenceTimeInds; % Get the sequence numbers of each data point
            %             end
            
            stimTimeInds = smoothingSize:(smoothingSize + numTimeSteps - 1); % Causal
            
            markersInds = round(linspace(1, numTimeSteps, numMarkers));
            if useTimeXAxis
                potXAxis = adjustedStimTimesCol(stimTimeInds); % Get the times of each sequence firing (use the time of the sequence at the center of the smoothing window)
            else
                potXAxis = stimTimeInds(:); % Get the sequence numbers of each data point
            end
            
            % Determine where the GT values change in this trial
            GTChangeInds = find(diff(N1.sequenceInfo(seqInfoInds1,end - 1)) | diff(N1.sequenceInfo(seqInfoInds1,end)) | diff(N2.sequenceInfo(seqInfoInds2,end - 1)) | diff(N2.sequenceInfo(seqInfoInds2,end)))';
            
            % Check if user already set the start and end times
            timeStart = 0; % What time (in minutes) should be the start of the included sequences?
            timeEnd = Inf; % What time (in minutes) should be the end of the included sequences?
            
            % Get adaptation information
            doAdapt = false;
            adaptiveInfo1 = [];
            adaptiveInfo2 = [];
            epochStartInds = [];
            if ~isempty(GTChangeInds) || thisGenerateAnalysisData
                % If there were changes to the GT sets
                numSequencesPerBlock = numSequencesPerRun/2; % Asserting that there are 2 blocks per run (technically can change, but...it probably won't)
                epochStartInds = 1:numSequencesPerBlock:numSequences;
                
%                 epochStartInds = GTChangeInds;
                
                if ~isempty(GTChangeInds)
                    if useTimeXAxis
                        epochStartLocs = adjustedSequenceTimes(epochStartInds);
                    else
                        epochStartLocs = epochStartInds;
                    end
                    
                    %                         GTChangeIndsWithInit = [0 GTChangeInds];
                    doAdapt = true;
                    
                    numBlocks = length(epochStartInds);
                end
            end
            
            % Find the spike indices for each voltage trace
            tDataOriginal = linspace(0,maxTimeRecorded,sizeData);
            spikeHitInds = nan(numUnits, numAllStims);
            for unitNum = 1:numUnits
                switch unitNum
                    case 1
                        thisIndsT = indsInResultsData1; % Transpose thisInds as it comes out of the matrix...
                        thisInds = thisIndsT(:); % ...so that it can be column indexed along the correct dimension.
                        tEnds1 = [0 max([lengthWaveformPart; N1.triggerTimespan(thisInds,2)])];
                        tEnds = tEnds1;
                        nS = N1;
                    case 2
                        thisIndsT = indsInResultsData2; % Transpose thisInds as it comes out of the matrix...
                        thisInds = thisIndsT(:); % ...so that it can be column indexed along the correct dimension.
                        tEnds2 = [0 max([lengthWaveformPart; N2.triggerTimespan(thisInds,2)])];
                        tEnds = tEnds2;
                        nS = N2;
                end
                
                indsCroppedData = tEnds(1) <= tDataOriginal & tDataOriginal <= tEnds(2);
                indsCroppedPCA = (tEnds(1) + thisPCACodeDelay) <= tDataOriginal & tDataOriginal <= (tEnds(2) + thisPCACodeDelay);
                firstInd = find(indsCroppedData, 1) - 1; % The index of the first sample included in the trigger timespan, relative to the entire trace
                firstIndPCA = find(indsCroppedPCA, 1) - 1; % The index of the first sample included in the trigger timespan for PCA, relative to the entire trace
                tData = tDataOriginal(indsCroppedData);
                lengthTrace = length(tData);
                
                for traceNum = 1:length(thisInds)
                    t = thisInds(traceNum);
                    traceInds = 1:lengthTrace;
                    thisTraceSpike = nS.resultsData(t, 3);
                    
                    if thisTraceSpike
                        spikeHitInd = find(nS.pcaSortCodes{t}(indsCroppedPCA) == 1, 1); % The index at which a spike is detected (adjusted for the fact that there is a delay between a spike and its PCA code)
                        %                             spikeHitInd = spikeHitInd + firstIndPCA;
                    end
                    
                    if ~thisTraceSpike || isempty(spikeHitInd)
                        % If this trace did not have a
                        % spike, or it DID have a spike and
                        % no online sortcode was found (it
                        % was an offline sorted trace)
                        [~, spikeHitInd] = max(nS.voltageTraces{t}(indsCroppedData)); % Simply align all of the non-spike data around its max voltage location
                        spikeHitInd = spikeHitInd + firstInd;
                    end
                    
                    if ~isempty(spikeHitInd)% && (spikeHitInd<=length(tData))
                        % If a spike was found for this trace, align the time
                        % series to it
                        spikeHitInds(unitNum, traceNum) = spikeHitInd;
                    end
                end
            end
            
            %% Allow user to pick different segments of the trial
            haveTimes = false; % The user has not yet selected times for this trial
            if ~thisGenerateAnalysisData
                % If the purpose of this run is NOT simply to save data to
                % file for later cross-date comparrison
                while true
                    if doPerfOverTimePlot% || thisDoCompareTracesPlot
                        %% Plot total unit performance
                        hPOT = figure;
                        a = axes;
                        h = zeros(1,4);
                        legendStrings = {'P(A|SA)', 'P(B|SA)', 'P(B|SB)', 'P(A|SB)'};
                        plot(a, potXAxis, TP1, TP1LineStr, potXAxis, TP2, TP2LineStr, potXAxis, FA1, FA1LineStr, potXAxis, FA2, FA2LineStr, 'linewidth', plotLineWidth, 'markersize', markerSize);
                        hold on;
                        h(1:4) = plot(a, potXAxis(markersInds), TP1(markersInds), TP1MarkStr, potXAxis(markersInds), FA2(markersInds), FA2MarkStr, potXAxis(markersInds), TP2(markersInds), TP2MarkStr, potXAxis(markersInds), FA1(markersInds), FA1MarkStr, 'linewidth', plotLineWidth, 'markersize', markerSize);
                        if ~(isinf(timeEnd))
                            hl = length(h);
                            h = [h plot(a, [timeStart timeEnd;timeStart timeEnd], [0 0;1 1], 'c:', 'linewidth', 2)'];
                            h = h(1:(hl + 1));
                            legendStrings = [legendStrings {'Section Limits'}];
                        end
                        
                        if doAdapt
                            hl = length(h);
                            h = [h plot(a, repmat(epochStartLocs,2,1), repmat([0;1.05],1,length(epochStartLocs)), 'm:', 'linewidth', 2)'];
                            
                            if any(diff(allG1(epochStartInds)) > 0)
                                plot(epochStartLocs(find(diff(allG1(epochStartInds)) > 0) + 1), adaptivePOTLoc1, 'b^', 'markersize', adaptiveGTMarkerSize); % G1 Increases
                            end
                            
                            if any(diff(allG1(epochStartInds)) < 0)
                                plot(epochStartLocs(find(diff(allG1(epochStartInds)) < 0) + 1), adaptivePOTLoc1, 'bv', 'markersize', adaptiveGTMarkerSize); % G1 Decreases
                            end
                            
                            if any(diff(allG2(epochStartInds)) > 0)
                                plot(epochStartLocs(find(diff(allG2(epochStartInds)) > 0) + 1), adaptivePOTLoc2, 'r^', 'markersize', adaptiveGTMarkerSize); % G2 Increases
                            end
                            
                            if any(diff(allG2(epochStartInds)) < 0)
                                plot(epochStartLocs(find(diff(allG2(epochStartInds)) < 0) + 1), adaptivePOTLoc2, 'rv', 'markersize', adaptiveGTMarkerSize); % G2 Decreases
                            end
                            
                            for blockInd = 2:numBlocks
                                if diff(allG1(epochStartInds(blockInd + [-1 0]))) ~= 0
                                    text(epochStartLocs(blockInd), adaptivePOTLoc1, sprintf('  %0.3f', allG1(epochStartInds(blockInd))), 'fontsize', adaptiveGTFontSize);
                                end
                                
                                if diff(allG2(epochStartInds(blockInd + [-1 0]))) ~= 0
                                    text(epochStartLocs(blockInd), adaptivePOTLoc2, sprintf('  %0.3f', allG2(epochStartInds(blockInd))), 'fontsize', adaptiveGTFontSize);
                                end
                            end
                            
                            text(0, adaptivePOTLoc1, sprintf('  %0.3f', allG1(1)), 'fontsize', adaptiveGTFontSize);
                            text(0, adaptivePOTLoc2, sprintf('  %0.3f', allG2(1)), 'fontsize', adaptiveGTFontSize);
                            
                            h = h(1:(hl + 1));
                            legendStrings = [legendStrings {'GT Adaptation'}];
                            ylim(a, [0 1.25]);
                            set(a, 'YTick', 0:.2:1);
                        else
                            ylim(a, [0 1]);
                        end
                        axes(a);
                        %                         title(a, sprintf('t = %dms (n = %d, P[A] = %0.2f, P[B] = %0.2f)', thisIS, numel(eRAll1), fractionOfTotal(eRAll1), fractionOfTotal(eRAll2)), 'fontsize', plotFontSize);
                        title(a, sprintf('Response Fractions over Time (n = %d stimulations)', numAllStims), 'fontsize', plotFontSize);
                        if useTimeXAxis
                            %                             xlabel(a, 'Sequence Start Time (minutes)', 'fontsize', plotFontSize);
                            xlabel(a, 'Stimulation Time (minutes)', 'fontsize', plotFontSize);
                        else
                            %                             xlabel(a, 'Sequence Number', 'fontsize', plotFontSize);
                            xlabel(a, 'Stimulation Number', 'fontsize', plotFontSize);
                        end
                        ylabel(a, 'Response Fraction', 'fontsize', plotFontSize)
                        set(a, 'fontsize', plotFontSize);
                        plot(a, xlim, [1 1], 'k'); % Make a clear upper boundary on the plot
                        legend(h, legendStrings, 'fontsize', legendFontSize, 'location', 'northeast');
                        
                        hasERPlot = false;
                        
                        if doCostOverTimePlot
                            % Do the cost over time plot
                            hCOT = figure;
                            a = axes;
                            hold(a, 'on')
                            h = plot(a, potXAxis, cost1, 'b-', potXAxis, cost2, 'r-', potXAxis, cost1 + cost2, 'k-', 'linewidth', plotLineWidth);
                            yLims = [adaptiveCostFunction(1, 0, 0) adaptiveCostFunction(0, 1, 0)];
                            if doAdapt
                                plot(a, repmat(epochStartLocs,2,1), repmat(yLims',1,length(epochStartInds)), 'm:', 'linewidth', 2);
                            end
                            plot(a, xlim, [0 0], 'k--');
                            
                            legend(h, {'Cost A', 'Cost B', 'Total Cost'});
                            if useTimeXAxis
                                xlabel('Time (minutes)', 'fontsize', plotFontSize);
                            else
                                %                                     xlabel('Sequence Number', 'fontsize', plotFontSize);
                                xlabel(a, 'Stimulation Number', 'fontsize', plotFontSize);
                            end
                            ylabel('Cost', 'fontsize', plotFontSize);
                            title('Cost function over time', 'fontsize', plotFontSize);
                            set(a, 'fontsize', plotFontSize);
                            ylim(yLims);
                        end
                        
                        if doAdapt
                            hasERPlot = doAdapt && (sortInd == 2);
                            if hasERPlot && doEpochResultsPlot
                                % If this experiment used adaptation, and this is
                                % the offline run of the analysis
                                ticks = 0:.25:1;
                                labels = strsplit(num2str(ticks));
                                set(a, 'YTickLabel', labels, 'YTick', ticks); % Remove any tick labels above 1
                                
                                %% Create the GT adaptation epoch figure
                                % Prepare stimulation results for the online sort
                                NA2 = allMatStruct{fileNumInd, 1, 1};
                                NB2 = allMatStruct{fileNumInd, 2, 1};
                                
                                stimResultsAllA2 = NA2.resultsData(:,3);
                                stimResultsAllB2 = NB2.resultsData(:,3);
                                
                                stimResultsThisTrialA2 = stimResultsAllA2(indsInResultsData1); % Results of the stimulations in the trial
                                stimResultsThisTrialB2 = stimResultsAllB2(indsInResultsData2);
                                
                                stimResultsTA2 = stimResultsThisTrialA2';
                                stimResultsColA2 = stimResultsTA2(:);
                                stimResultsTB2 = stimResultsThisTrialB2';
                                stimResultsColB2 = stimResultsTB2(:);
                                
                                TPMeshA1 = nan(length(epochStartInds), numMainPointsPerNeuron - 1);
                                FAMeshA1 = nan(length(epochStartInds), numMainPointsPerNeuron - 1);
                                TPMeshB1 = nan(length(epochStartInds), numMainPointsPerNeuron - 1);
                                FAMeshB1 = nan(length(epochStartInds), numMainPointsPerNeuron - 1);
                                TPMeshA2 = nan(length(epochStartInds), numMainPointsPerNeuron - 1);
                                FAMeshA2 = nan(length(epochStartInds), numMainPointsPerNeuron - 1);
                                TPMeshB2 = nan(length(epochStartInds), numMainPointsPerNeuron - 1);
                                FAMeshB2 = nan(length(epochStartInds), numMainPointsPerNeuron - 1);
                                
                                meshStimStrengths1 = zeros(length(epochStartInds), numMainPointsPerNeuron - 1);
                                meshStimStrengths2 = zeros(length(epochStartInds), numMainPointsPerNeuron - 1);
                                
                                epochBoundaryInds = [epochStartInds (numSequences + 1)]; % Define the boundaries of each epoch, given by the sequence when each epoch starts (so the last epoch ends right before (numSequences + 1))
                                for blockInd = 1:length(epochStartInds)
                                    % Prep data for figure
                                    stimStrengthsInds1 = (epochBoundaryInds(blockInd) - 1)*numStimsPerSequence + find(eRAll1(epochBoundaryInds(blockInd):(epochBoundaryInds(blockInd + 1) - 1), :)');
                                    stimStrengthsInds2 = (epochBoundaryInds(blockInd) - 1)*numStimsPerSequence + find(eRAll2(epochBoundaryInds(blockInd):(epochBoundaryInds(blockInd + 1) - 1), :)');
                                    
                                    thisAllStimStrengths1 = stimStrengthsThisTrial(stimStrengthsInds1(:));
                                    thisAllStimStrengths2 = stimStrengthsThisTrial(stimStrengthsInds2(:));
                                    
                                    if length(unique(thisAllStimStrengths1)) > 1
                                        [occurences1, uniqueStrengths1] = hist(thisAllStimStrengths1, unique(thisAllStimStrengths1));
                                        [~, order1] = sort(occurences1, 'descend');
                                        uniqueStrengthsInOrder1 = uniqueStrengths1(order1);
                                        numStrs1 = length(uniqueStrengthsInOrder1);
                                        thisStimStrengths1 = sort(uniqueStrengthsInOrder1(1:min(3,numStrs1)));
                                        meshStimInds1 = 1:min(3,numStrs1);
                                    else
                                        thisStimStrengths1 = unique(thisAllStimStrengths1);
                                        numStrs1 = 1;
                                        meshStimInds1 = 2;
                                    end
                                    
                                    if length(unique(thisAllStimStrengths2)) > 1
                                        [occurences2, uniqueStrengths2] = hist(thisAllStimStrengths2, unique(thisAllStimStrengths2));
                                        [~, order2] = sort(occurences2, 'descend');
                                        uniqueStrengthsInOrder2 = uniqueStrengths2(order2);
                                        numStrs2 = length(uniqueStrengthsInOrder2);
                                        thisStimStrengths2 = sort(uniqueStrengthsInOrder2(1:min(3,numStrs2)));
                                        meshStimInds2 = 1:min(3,numStrs2);
                                    else
                                        thisStimStrengths2 = unique(thisAllStimStrengths2);
                                        numStrs2 = 1;
                                        meshStimInds2 = 2;
                                    end
                                    
                                    %                                     thisStimStrengths1 = sort(unique(thisAllStimStrengths1));
                                    %                                     thisStimStrengths2 = sort(unique(thisAllStimStrengths2));
                                    
                                    meshStimStrengths1(blockInd, meshStimInds1) = thisStimStrengths1';
                                    meshStimStrengths2(blockInd, meshStimInds2) = thisStimStrengths2';
                                    
                                    [~, strLocs1] = ismember(thisAllStimStrengths1, thisStimStrengths1);
                                    [~, strLocs2] = ismember(thisAllStimStrengths2, thisStimStrengths2);
                                    
                                    [~, ~, pointNumInds1] = unique(thisStimStrengths1, 'stable'); % Deals with cases where there are less than (numPointsPerNeuron - 1) unique stimulation strengths
                                    [~, ~, pointNumInds2] = unique(thisStimStrengths2, 'stable');
                                    
                                    for pointNum = 1:1:min([3 numStrs1 numStrs2])
                                        if min([3 numStrs1 numStrs2]) == 1
                                            thisInd = 2;
                                        else
                                            thisInd = pointNum;
                                        end
                                        TPMeshA1(blockInd, thisInd) = mean(sRCol1(stimStrengthsInds1(strLocs1 == pointNumInds1(pointNum))));
                                        FAMeshA1(blockInd, thisInd) = mean(sRCol1(stimStrengthsInds2(strLocs2 == pointNumInds2(pointNum))));
                                        
                                        TPMeshB1(blockInd, thisInd) = mean(sRCol2(stimStrengthsInds2(strLocs2 == pointNumInds2(pointNum))));
                                        FAMeshB1(blockInd, thisInd) = mean(sRCol2(stimStrengthsInds1(strLocs1 == pointNumInds1(pointNum))));
                                        
                                        TPMeshA2(blockInd, thisInd) = mean(stimResultsColA2(stimStrengthsInds1(strLocs1 == pointNumInds1(pointNum))));
                                        FAMeshA2(blockInd, thisInd) = mean(stimResultsColA2(stimStrengthsInds2(strLocs2 == pointNumInds2(pointNum))));
                                        
                                        TPMeshB2(blockInd, thisInd) = mean(stimResultsColB2(stimStrengthsInds2(strLocs2 == pointNumInds2(pointNum))));
                                        FAMeshB2(blockInd, thisInd) = mean(stimResultsColB2(stimStrengthsInds1(strLocs1 == pointNumInds1(pointNum))));
                                    end
                                end
                                
                                % Create an adaptation figure to show the locations
                                % and results of each tested G in each mesh for
                                % both neurons
                                cFA1 = adaptiveCostFunction(TPMeshA1, FAMeshB1); % Cost function of GT_A
                                cFB1 = adaptiveCostFunction(TPMeshB1, FAMeshA1); % Cost function of GT_B
                                %                         cFA1T = cFA1';
                                %                         cFB1T = cFB1';
                                
                                cFA2 = adaptiveCostFunction(TPMeshA2, FAMeshB2); % Cost function of GT_A
                                cFB2 = adaptiveCostFunction(TPMeshB2, FAMeshA2); % Cost function of GT_B
                                cFA2T = cFA2';
                                cFB2T = cFB2';
                                
                                labelRot = 45;
                                meshStimStrengths1T = meshStimStrengths1';
                                meshStimStrengths2T = meshStimStrengths2';
                                xLabels1 = cellfun(@num2str, num2cell(meshStimStrengths1T(:)),'uniformoutput', false);
                                xLabels2 = cellfun(@num2str, num2cell(meshStimStrengths2T(:)),'uniformoutput', false);
                                
                                [~, minInds1] = min(cFA2, [], 2);
                                [~, minInds2] = min(cFB2, [], 2);
                                minSubs1 = sub2ind(size(cFA2T), minInds1, (1:size(cFA2T,2))');
                                minSubs2 = sub2ind(size(cFB2T), minInds2, (1:size(cFB2T,2))');
                                
                                numChangeCases = size(TPMeshA1,2);
                                numGroups = length(epochStartInds);
                                groupwidth = min(0.8, numChangeCases/(numChangeCases+1.5)); % Needed to align errorbars to bar graph
                                barPositions = repmat(1:numGroups,numChangeCases,1) - groupwidth/2 + (2*repmat((1:numChangeCases)',1,numGroups) -1) * groupwidth / (2*numChangeCases);  % Based on barweb.m by Bolu Ajiboye from MATLAB File Exchange, via MathWorks Support Team on Mathworks
                                
                                if doEpochResultsPlot
                                    hER = figure;
                                    a1 = subplot(2,1,1);
                                    a2 = subplot(2,1,2);
                                    hold(a1, 'on');
                                    hold(a2, 'on');
                                    bA1 = bar(a1, cFA1);
                                    bB1 = bar(a2, cFB1);
                                    bA2 = bar(a1, cFA2, .3);
                                    bB2 = bar(a2, cFB2, .3);
                                    
                                    set(bA2, 'EdgeColor', [.5 .5 1]);
                                    set(bB2, 'EdgeColor', [1 .5 .5]);
                                    
                                    set(a1, 'XTick', barPositions(:), 'XTickLabel', xLabels1, 'XTickLabelRotation', labelRot);
                                    set(a2, 'XTick', barPositions(:), 'XTickLabel', xLabels2, 'XTickLabelRotation', labelRot);
                                    
                                    for i = 1:length(bA1)
                                        bA1(i).FaceColor = [0 0 1];
                                        bB1(i).FaceColor = [1 0 0];
                                        
                                        bA2(i).FaceColor = [0 0 .6];
                                        bB2(i).FaceColor = [.6 0 0];
                                    end
                                    
                                    x1 = plot(a1, barPositions(minSubs1), cFA2T(minSubs1), 'kx', 'markersize', adaptiveGTMarkerSize, 'linewidth', plotLineWidth);
                                    x2 = plot(a2, barPositions(minSubs2), cFB2T(minSubs2), 'kx', 'markersize', adaptiveGTMarkerSize, 'linewidth', plotLineWidth);
                                    
                                    suptitle('Cost Function Values for Each Epoch');
                                    title(a1, 'Unit A');
                                    title(a2, 'Unit B');
                                    
                                    %                         xlabel(a2, 'Epoch (strength of each stim)')
                                    ylabel(a1, 'Cost function value');
                                    ylabel(a2, 'Cost function value');
                                    
                                    set(a1, 'fontsize', plotSmallFontSize);
                                    set(a2, 'fontsize', plotSmallFontSize);
                                    
                                    legend([bA1(1) bA2(1) x1], {'Offline Sort', 'Online Sort', 'Online decision'}, 'location', 'northeastoutside');
                                    legend([bB1(1) bB2(1) x1], {'Offline Sort', 'Online Sort', 'Online decision'}, 'location', 'northeastoutside');
                                end
                            else
                                %                         ylim(a, [0 1]);
                            end
                        end
                        
                    end
                    
                    if doPerfPerBlockPlot
                        % Get the performance of each block
                        %                         allBlockBorders = [1 GTChangeInds*numStims numAllStims];
                        allBlockBorders = 1:sizeAdaptationBlock*numStimsPerSequence:(numAllStims + 1);
                        numAdaptationBlocks = length(allBlockBorders) - 1;
                        TP1_block = ones(numAdaptationBlocks, 1);
                        TP2_block = ones(numAdaptationBlocks, 1);
                        FA1_block = ones(numAdaptationBlocks, 1);
                        FA2_block = ones(numAdaptationBlocks, 1);
                        costs1_block = ones(numAdaptationBlocks, 1);
                        costs2_block = ones(numAdaptationBlocks, 1);
                        strs1_block = ones(numAdaptationBlocks, 1);
                        durs1_block = ones(numAdaptationBlocks, 1);
                        strs2_block = ones(numAdaptationBlocks, 1);
                        durs2_block = ones(numAdaptationBlocks, 1);
                        timeAxis = ones(numAdaptationBlocks, 1);
                        
                        for blockInd = 1:numAdaptationBlocks
                            thisAllInds = allBlockBorders(blockInd):(allBlockBorders(blockInd + 1) - 1);
                            eRInds1 = logical(eRAll1Col(thisAllInds));
                            eRInds2 = logical(eRAll2Col(thisAllInds));
                            eRInds1 = thisAllInds(eRInds1);
                            eRInds2 = thisAllInds(eRInds2);
                            
                            % For neuron 1 stimulations
                            thisSR11 = sRCol1(eRInds1);
                            thisSR21 = sRCol2(eRInds1);
                            thisStrs1 = sStrsCol(eRInds1);
                            TP1_block(blockInd) = mean(thisSR11);
                            FA2_block(blockInd) = mean(thisSR21);
                            costs1_block(blockInd) = adaptiveCostFunction(TP1_block(blockInd), FA2_block(blockInd), thisStrs1(1));
                            
                            % For neuron 2 stimulations
                            thisSR12 = sRCol1(eRInds2);
                            thisSR22 = sRCol2(eRInds2);
                            thisStrs2 = sStrsCol(eRInds2);
                            TP2_block(blockInd) = mean(thisSR22);
                            FA1_block(blockInd) = mean(thisSR12);
                            costs2_block(blockInd) = adaptiveCostFunction(TP2_block(blockInd), FA1_block(blockInd), thisStrs2(1));
                            
                            % Get general block data
                            timeAxis(blockInd) = adjustedStimTimesCol(round(mean(thisAllInds)));
                            strs1_block(blockInd) = thisStrs1(1);
                            durs1_block(blockInd) = sDursCol(eRInds1(1));
                            strs2_block(blockInd) = thisStrs2(1);
                            durs2_block(blockInd) = sDursCol(eRInds2(1));
                            
                            %                             %% Plot the results
                            %                             plot(a, seqInds1([1 end]), [TP1_block(blockInd) TP1_block(blockInd)], TP1CombStr, seqInds1([1 end]), [FA2_block(blockInd) FA2_block(blockInd)], FA2CombStr, seqInds2([1 end]), [TP2_block(blockInd) TP2_block(blockInd)], TP2CombStr, seqInds2([1 end]), [FA1_block(blockInd) FA1_block(blockInd)], FA1CombStr);
                        end
                        
                        if doCompareToOptimal
                            % Calculate the optimal performance if the
                            % given thetas are correct
                            
                            opts1 = N1.optS;
                            opts2 = N2.optS;
                            
                            % Load the dataset needed for approxFun
                            load(FPDataFile)
                            allStrs_Raw = allStrs;
                            b0_Raw = eval('beta'); % Fucking Matlab
                            
                            % Load the laser equation
                            %                             laserEqFileName = sprintf('%s%s%s%slaserEqVals%s.mat', dataDirBase, filesep, dateStr, filesep, dateStr);
                            if ~isempty(N1.laserEQ)
                                laserEq = N1.laserEQ;
                            else
                                laserEq = [-9.97570000000000,75.5625000000000,201.584700000000,-10.7840000000000];
                            end
                            laserRadius = .1;
                            powToIrr = 1/((laserRadius^2)*pi*1000);
                            irrAtMaxG = powToIrr*polyval(laserEq, allStrs_Raw(end));
                            irrRatio = irrAtMaxG/allStrs_Raw(end);
                            
                            % Adjust all strengths and beta's
                            allStrs = allStrs_Raw*irrRatio;
                            b0 = b0_Raw/irrRatio;
                            
                            % Set up the needed functions
                            costFunLambda = 1e-5; %.01;
                            costFun = @(P1, P2, GT) -(P1 .* (1 - P2)) + costFunLambda*(GT(:, 1).^2); % Cost function to optimize using control
                            approxFun = @(GT, t) lininterpn(allStrs, allDurs, allAlphas, allSigmas, PAll, GT(:, 1)*(t(2)/b0), GT(:, 2), t(1), t(3));
                            optCostFun = @(GT, t1, t2) costFun(approxFun(GT, t1), approxFun(GT, t2), GT);
                            
                            % Set up variables to store the results
                            optTP1_block = zeros(numAdaptationBlocks, 1);
                            optTP2_block = zeros(numAdaptationBlocks, 1);
                            optFA1_block = zeros(numAdaptationBlocks, 1);
                            optFA2_block = zeros(numAdaptationBlocks, 1);
                            optCosts1_block = zeros(numAdaptationBlocks, 1);
                            optCosts2_block = zeros(numAdaptationBlocks, 1);
                            
                            for blockInd = 1:numAdaptationBlocks
                                thisGTA = [strs1_block(blockInd) durs1_block(blockInd)];
                                thisGTB = [strs2_block(blockInd) durs2_block(blockInd)];
                                thisTheta1 = opts1(blockInd).thetas;
                                thisTheta2 = opts2(blockInd).thetas;
                                
                                optTP1_block(blockInd) = approxFun(thisGTA, thisTheta1);
                                optTP2_block(blockInd) = approxFun(thisGTB, thisTheta2);
                                optFA1_block(blockInd) = approxFun(thisGTA, thisTheta2);
                                optFA2_block(blockInd) = approxFun(thisGTB, thisTheta1);
                                
                                optCosts1_block(blockInd) = optCostFun(thisGTA, thisTheta1, thisTheta2);
                                optCosts2_block(blockInd) = optCostFun(thisGTB, thisTheta2, thisTheta1);
                            end
                        end
                        
                        % Get the total cost by taking the mean of the two
                        % costs
                        costsT_block = mean([costs1_block costs2_block], 2);
                        
                        %% Plot the results
                        % Performance per block
                        blockTickPitch = 5;
                        blockTickLabels = 0:blockTickPitch:numAdaptationBlocks;
                        blockTickLabels(1) = [];
                        blockTickLocs = timeAxis(blockTickLabels);
                        
                        hPPB = figure;
                        a = axes;
                        
                        hold(a, 'on');
                        h = plot(a, timeAxis, TP1_block, TP1CombStr, timeAxis, TP2_block, TP2CombStr, timeAxis, FA1_block, FA1CombStr, timeAxis, FA2_block, FA2CombStr, 'Markersize', markerSize, 'linewidth', plotLineWidth);
                        legendStrs = {'P(N1 | A)', 'P(N2 | B)', 'P(N1 | B)', 'P(N2 | A)'};
                        if doMarginalIndicator
                            xLims = xlim;
                            S1Offset = -diff(xLims)*.02;
                            S2Offset = 0;
                            
                            % Plot the s.e.m.
                            semTP1 = std(TP1_block)/sqrt(numAllStims); % TODO: Use numAllStims, or numAdaptationBlocks?
                            semTP2 = std(TP2_block)/sqrt(numAllStims);
                            semFA1 = std(FA1_block)/sqrt(numAllStims);
                            semFA2 = std(FA2_block)/sqrt(numAllStims);
                            
                            plot(a, xLims([2 2]) + S1Offset, mean(TP1_block) + semTP1*[-1 1], 'b-', 'linewidth', 2);
                            plot(a, xLims([2 2]) + S2Offset, mean(TP2_block) + semTP2*[-1 1], 'r-', 'linewidth', 2);
                            plot(a, xLims([2 2]) + S2Offset, mean(FA1_block) + semFA1*[-1 1], 'b-', 'linewidth', 2);
                            plot(a, xLims([2 2]) + S1Offset, mean(FA2_block) + semFA2*[-1 1], 'r-', 'linewidth', 2);
                            
                            j = plot(a, xLims(2) + S1Offset, mean(TP1_block), 'b<', 'markersize', markerSize, 'linewidth', 5);
                            k = plot(a, xLims(2) + S2Offset, mean(TP2_block), 'r<', 'markersize', markerSize, 'linewidth', 5);
                            plot(a, xLims(2) + S2Offset, mean(FA1_block), 'b<', 'markersize', markerSize, 'linewidth', 3);
                            plot(a, xLims(2) + S1Offset, mean(FA2_block), 'r<', 'markersize', markerSize, 'linewidth', 3);
                            xlim(a, xLims); % Reset the limits of the plot
                            h = [h;j(1);k(1)];
                            legendStrs = [legendStrs {'N1 Mean', 'N2 Mean'}];
                        end
                        
                        if doCompareToOptimal
                            plot(a, timeAxis, optTP1_block, 'bx--', timeAxis, optTP2_block, 'ro--', timeAxis, optFA1_block, 'bo--', timeAxis, optFA2_block, 'rx--', 'linewidth', 1, 'markersize', 5);
                        end
                        a_ = axes('Position', a.Position, 'XAxisLocation', 'top', 'Color', 'none', 'xlim', a.XLim([1 end]), 'YTick', [], 'XTick', blockTickLocs, 'XTickLabel', num2cell(blockTickLabels));
                        
                        xlabel(a, 'Sequence Time (min)');
                        ylabel(a, 'Performance');
                        title(a, 'Performance Per Block');
                        oldTitlePos = a.Title.Position;
                        a.Title.Position = oldTitlePos + [0 .035 0];
                        legend(h, legendStrs);
                        set(a, 'fontsize', plotFontSize);
                        set(a_, 'fontsize', plotFontSize);
                        
                        % Cost per block
                        hCPB = figure;
                        a = axes;
                        hold(a, 'on');
                        h = plot(a, timeAxis, costs1_block, 'b-', timeAxis, costs2_block, 'r-', timeAxis, costsT_block, 'k-', 'linewidth', plotLineWidth);
                        if doCompareToOptimal
                            plot(a, timeAxis, optCosts1_block, 'b--', timeAxis, optCosts2_block, 'r--', 'linewidth', 1);
                        end
                        a_ = axes('Position', a.Position, 'XAxisLocation', 'top', 'Color', 'none', 'xlim', a.XLim([1 end]), 'YTick', [], 'XTick', blockTickLocs, 'XTickLabel', num2cell(blockTickLabels));
                        
                        xlabel(a, 'Sequence Time (min)');
                        ylabel(a, 'Cost');
                        title(a, 'Cost Per Block');
                        oldTitlePos = a.Title.Position;
                        a.Title.Position = oldTitlePos + [0 .03 0];
                        legend(h, {'Cost 1', 'Cost 2', 'Overall Cost'});
                        ylim([adaptiveCostFunction(1, 0, 0) adaptiveCostFunction(0, 1, 0)]);
                        set(a, 'fontsize', plotFontSize);
                        set(a_, 'fontsize', plotFontSize);
                        
                        % Strength vs duration
                        c = jet(numAdaptationBlocks - 1);
                        hGTT1 = figure;
                        a = axes;
                        hold(a, 'on')
                        for blockInd = 1:(numAdaptationBlocks - 1)
                            plot(a, durs1_block([blockInd (blockInd + 1)])', strs1_block([blockInd (blockInd + 1)])', 'x-', 'Color', c(blockInd, :), 'Markersize', markerSize, 'linewidth', plotLineWidth);
                        end
                        colormap(c);
                        colorbar;
                        caxis([0 numAdaptationBlocks]);
                        xlabel(a, 'Durations (ms)');
                        ylabel(a, 'Strengths (mW/mm^2)');
                        title(a, 'GT progression of Neuron 1 per adaptive block of the experiment');
                        ylim([0 50]);
                        xlim([0 15]);
                        set(a, 'fontsize', plotFontSize);
                        
                        hGTT2 = figure;
                        a = axes;
                        hold(a, 'on')
                        for blockInd = 1:(numAdaptationBlocks - 1)
                            plot(a, durs2_block([blockInd (blockInd + 1)])', strs2_block([blockInd (blockInd + 1)])', 'x-', 'Color', c(blockInd, :), 'Markersize', markerSize, 'linewidth', plotLineWidth);
                        end
                        colormap(c);
                        colorbar;
                        caxis([0 numAdaptationBlocks]);
                        xlabel(a, 'Durations (ms)');
                        ylabel(a, 'Strengths (mW/mm^2)');
                        title(a, 'GT progression of Neuron 2 per adaptive block of the experiment');
                        ylim([0 50]);
                        xlim([0 15]);
                        set(a, 'fontsize', plotFontSize);
                        
                        % Strength and duration over time
                        if doPlotPower
                            nSubPlots = 3;
                            plotFontSize = 16;
                        else
                            nSubPlots = 2;
                        end
                        
                        hGTD = figure;
                        a1 = subplot(nSubPlots, 1, 1);
                        a2 = subplot(nSubPlots, 1, 2);
                        
                        plot(a1, timeAxis, strs1_block, TP1CombStr, timeAxis, strs2_block, TP2CombStr, 'Markersize', markerSize, 'linewidth', plotLineWidth);
                        axes('Position', a1.Position, 'XAxisLocation', 'top', 'Color', 'none', 'xlim', a1.XLim([1 end]), 'YTick', [], 'XTick', blockTickLocs, 'XTickLabel', num2cell(blockTickLabels));
                        title(a1, 'Strength over Time');
                        set(a1, 'box', 'off');
                        xlabel(a1, 'Sequence Time (min)');
                        ylabel(a1, 'Strengths (mW/mm^2)');
                        legend(a1, 'N1 Strengths', 'N2 Strengths');
                        ylim(a1, [0 50]);
                        oldTitlePos = a1.Title.Position;
                        a1.Title.Position = oldTitlePos + [0 3 0];
                        set(a1, 'fontsize', plotFontSize);
                        
                        plot(a2, timeAxis, durs1_block, TP1CombStr, timeAxis, durs2_block, TP2CombStr, 'Markersize', markerSize, 'linewidth', plotLineWidth);
                        axes('Position', a2.Position, 'XAxisLocation', 'top', 'Color', 'none', 'xlim', a2.XLim([1 end]), 'YTick', [], 'XTick', blockTickLocs, 'XTickLabel', num2cell(blockTickLabels));
                        title(a2, 'Duration over Time');
                        set(a2, 'box', 'off');
                        xlabel(a2, 'Sequence Time (min)');
                        ylabel(a2, 'Durations (ms)');
                        legend(a2, 'N1 Durations', 'N2 Durations');
                        ylim(a2, [0 15]);
                        oldTitlePos = a2.Title.Position;
                        a2.Title.Position = oldTitlePos + [0 1 0];
                        set(a2, 'fontsize', plotFontSize);
                        
                        if doPlotPower || doPlotRfVsDeviance
                            % First, calculate the power per block
                            pow1_block = (strs1_block.^2).*durs1_block;
                            pow2_block = (strs2_block.^2).*durs2_block;
                            if doPlotPower
                                a3 = subplot(nSubPlots, 1, 3);
                                plot(a3, timeAxis, pow1_block, TP1CombStr, timeAxis, pow2_block, TP2CombStr, 'Markersize', markerSize, 'linewidth', plotLineWidth);
                                axes('Position', a3.Position, 'XAxisLocation', 'top', 'Color', 'none', 'xlim', a3.XLim([1 end]), 'YTick', [], 'XTick', blockTickLocs, 'XTickLabel', num2cell(blockTickLabels));
                                title(a3, 'Power over Time');
                                set(a3, 'box', 'off');
                                xlabel(a3, 'Sequence Time(min)');
                                ylabel(a3, 'Power ((mW^2ms)/mm^4)');
                                legend(a3, 'N1 Powers', 'N2 Powers');
                                oldTitlePos = a3.Title.Position;
                                a3.Title.Position = oldTitlePos + [0 3 0];
                                set(a3, 'fontsize', plotFontSize);
                            end
                        end
                        
                        % Neuron parameters over time
                        paramsTimeAxis1 = timeAxis(1:size(parameters1, 1)); % Get the time axis for the parameters plot
                        paramsTimeAxis2 = timeAxis(1:size(parameters2, 1));
                        hNPT = figure;
                        a1 = subplot(3, 1, 1);
                        a2 = subplot(3, 1, 2);
                        a3 = subplot(3, 1, 3);
                        plot(a1, paramsTimeAxis1, parameters1(:, 1), 'bx-', paramsTimeAxis2, parameters2(:, 1), 'ro-', 'Markersize', markerSize, 'linewidth', plotLineWidth);
                        axes('Position', a1.Position, 'XAxisLocation', 'top', 'Color', 'none', 'xlim', a1.XLim([1 end]), 'YTick', [], 'XTick', blockTickLocs, 'XTickLabel', num2cell(blockTickLabels));
                        set(a1, 'box', 'off');
                        
                        title(a1, 'Neuron Parameters over time');
                        ylabel(a1, 'Alpha');
                        legend(a1, 'N1 parameters', 'N2 parameters');
                        ylim(a1, [0 1.1*max([parameters1(:, 1);parameters2(:, 1)])]);
                        oldTitlePos = a1.Title.Position;
                        a1.Title.Position = oldTitlePos + [0 .05 0];
                        set(a1, 'fontsize', plotFontSize);
                        
                        plot(a2, paramsTimeAxis1, parameters1(:, 2), 'bx-', paramsTimeAxis2, parameters2(:, 2), 'ro-', 'Markersize', markerSize, 'linewidth', plotLineWidth);
                        axes('Position', a2.Position, 'XAxisLocation', 'top', 'Color', 'none', 'xlim', a2.XLim([1 end]), 'YTick', [], 'XTick', blockTickLocs, 'XTickLabel', num2cell(blockTickLabels));
                        set(a2, 'box', 'off');
                        ylabel(a2, 'Beta');
                        ylim(a2, [0 1.1*max([parameters1(:, 2);parameters2(:, 2)])]);
                        set(a2, 'fontsize', plotFontSize);
                        
                        plot(a3, paramsTimeAxis1, parameters1(:, 3), 'bx-', paramsTimeAxis2, parameters2(:, 3), 'ro-', 'Markersize', markerSize, 'linewidth', plotLineWidth);
                        axes('Position', a3.Position, 'XAxisLocation', 'top', 'Color', 'none', 'xlim', a3.XLim([1 end]), 'YTick', [], 'XTick', blockTickLocs, 'XTickLabel', num2cell(blockTickLabels));
                        set(a3, 'box', 'off');
                        ylabel(a3, 'Sigma');
                        xlabel(a3, 'Sequence Time (min)');
                        ylim(a3, [0 1.1*max([parameters1(:, 3);parameters2(:, 3)])]);
                        set(a3, 'fontsize', plotFontSize);
                        
                        % Plot power deviance as a function of RF
                        if doPlotRfVsDeviance
                            % First, get the median of the metric for each
                            % stimulation
                            median_pow1 = median(pow1_block);
                            median_pow2 = median(pow2_block);
                            
                            % Next, calculate the deviance of each block
                            % from the median
                            deviance_pow1 = pow1_block - median_pow1;
                            deviance_pow2 = pow2_block - median_pow2;
                            
                            % Finally, plot the response fractions vs the
                            % deviance
                            hRFvD = figure;
                            a1 = subplot(2, 1, 1);
                            a2 = subplot(2, 1, 2);
                            plot(a1, deviance_pow1, TP1_block, 'bx', deviance_pow1, FA2_block, 'rx', 'Markersize', markerSize, 'Linewidth', plotLineWidth);
                            ylabel(a1, 'Response Fraction');
                            title(a1, sprintf('Stimulation A: Median = %0.1f', median_pow1));
                            legend(a1, 'Neuron 1', 'Neuron 2');
                            
                            plot(a2, deviance_pow2, FA1_block, 'bo', deviance_pow2, TP2_block, 'ro', 'Markersize', markerSize, 'Linewidth', plotLineWidth);
                            xlabel(a2, 'Deviance from median power');
                            ylabel(a2, 'Response Fraction');
                            title(a2, sprintf('Stimulation B: Median = %0.1f', median_pow2));
                            legend(a2, 'Neuron 1', 'Neuron 2');
                            suptitle('Response fraction as a function of stimulation deviance');
                        end
                        
                        if doPlotRFDifference || doPerfInGTHeatmap
                            % First, get the RF difference for each
                            % stimulation
                            diff1 = TP1_block - FA2_block;
                            diff2 = TP2_block - FA1_block;
                        end
                        
                        if doPlotRFDifference
                            % Plot the difference in response fractions vs
                            % block number/time
                            hRFD = figure;
                            a = axes;
                            hold(a, 'on');
                            plot(a, timeAxis, diff1, 'bx-', timeAxis, diff2, 'ro-', 'Markersize', markerSize, 'Linewidth', plotLineWidth);
                            xLims = xlim;
                            plot(a, xLims, [0 0], 'k:', 'linewidth', .5);
                            xlim(a, xLims);
                            a_ = axes('Position', a.Position, 'XAxisLocation', 'top', 'Color', 'none', 'xlim', a.XLim([1 end]), 'YTick', [], 'XTick', blockTickLocs, 'XTickLabel', num2cell(blockTickLabels));
                            
                            xlabel(a, 'Sequence Time (min)');
                            ylabel(a, 'Response Fraction Difference');
                            title(a, 'Response Fraction Difference per Block');
                            oldTitlePos = a.Title.Position;
                            a.Title.Position = oldTitlePos + [0 .035 0];
                            legend(a, 'Stimulation A', 'Stimulation B');
                            set(a, 'fontsize', plotFontSize);
                            set(a_, 'fontsize', plotFontSize);
                            ylim(a, [-1 1]);
                            
                            hRFSS = figure;
                            a = axes;
                            colorbar;
                            hold(a, 'on');
                            val = timeAxis';
                            z = zeros(size(val));
                            surface([diff1';diff1'], [diff2';diff2'], [z;z], [val;val], 'facecol', 'no', 'edgecol', 'interp', 'linew', 2);
                            title(a, 'Response Fraction Differences Trajectory');
                            xlabel(a, 'Response Fraction Difference A', 'fontsize', plotFontSize);
                            ylabel(a, 'Response Fraction Difference B', 'fontsize', plotFontSize);
                            set(a, 'fontsize', plotFontSize);
                            ylim(a, [-1 1]);
                            xlim(a, [-1 1]);
                            caxis(a, timeAxis([1 end]));
                        end
                        
                        if doPerfInGTHeatmap
                            % First, build a grid to apply the kernel to, one for each stimulation
                            gtGridA = zeros(gtHeatmapResolution);
                            gtGridB = zeros(gtHeatmapResolution);
                            
                            % Put the real duration and strength points in a
                            % vector, in the center (leaving the edges as
                            % nan slop space so that the kernel can spill
                            % over; removed later
                            trueTGridPoints = linspace(0, 15, gtHeatmapResolution);
                            trueGGridPoints = linspace(0, 50, gtHeatmapResolution);
                            
                            % Get the location of the center of each kernel
                            [~, tInds1] = min(abs(trueTGridPoints(:) - durs1_block(:)'), [], 1);
                            [~, gInds1] = min(abs(trueGGridPoints(:) - strs1_block(:)'), [], 1);
                            
                            [~, tInds2] = min(abs(trueTGridPoints(:) - durs2_block(:)'), [], 1);
                            [~, gInds2] = min(abs(trueGGridPoints(:) - strs2_block(:)'), [], 1);
                            
                            gtGridACounts = zeros(gtHeatmapResolution);
                            gtGridBCounts = zeros(gtHeatmapResolution);
                            
                            for blockInd = 1:length(diff1)
%                                gtGridA(tInds1(blockInd), gInds1(blockInd)) = diff1(blockInd);
%                                gtGridB(tInds2(blockInd), gInds2(blockInd)) = diff2(blockInd);
                               
                               gtGridA(tInds1(blockInd), gInds1(blockInd)) = gtGridA(tInds1(blockInd), gInds1(blockInd)) + diff1(blockInd);
                               gtGridB(tInds2(blockInd), gInds2(blockInd)) = gtGridB(tInds2(blockInd), gInds2(blockInd)) + diff2(blockInd);
                               
                               gtGridACounts(tInds1(blockInd), gInds1(blockInd)) = gtGridACounts(tInds1(blockInd), gInds1(blockInd)) + 1;
                               gtGridBCounts(tInds2(blockInd), gInds2(blockInd)) = gtGridBCounts(tInds2(blockInd), gInds2(blockInd)) + 1;
                            end
                            
                            % Normalize each grid location by the number of
                            % blocks spent at that GT
                            gtGridA = gtGridA./gtGridACounts;
                            gtGridB = gtGridB./gtGridBCounts;
                            gtGridA(isnan(gtGridA)) = 0;
                            gtGridB(isnan(gtGridB)) = 0;
                            
                            % Convolve each gtGrid with the kernel for
                            % display
                            gausskernel = gauss2DFcn(gtHeatmapKernelSize);
                            gtGridAConv = conv2(gtGridA, gausskernel, 'same');
                            gtGridBConv = conv2(gtGridB, gausskernel, 'same');
                                
%                             tGridPoints(ceil(gtHeatmapKernelSize/2):(ceil(gtHeatmapKernelSize/2) + gtHeatmapResolution - 1)) = trueTGridPoints;
%                             gGridPoints(ceil(gtHeatmapKernelSize/2):(ceil(gtHeatmapKernelSize/2) + gtHeatmapResolution - 1)) = trueGGridPoints;
%                             gtGridA = zeros(gtHeatmapResolution + gtHeatmapKernelSize);
%                             gtGridB = zeros(gtHeatmapResolution + gtHeatmapKernelSize);
%                             tGridPoints = nan(1, gtHeatmapResolution + gtHeatmapKernelSize);
%                             gGridPoints = nan(1, gtHeatmapResolution + gtHeatmapKernelSize);
%                             
%                             for blockInd = 1:length(diff1)
%                                 % First, get the kernels for each stim in
%                                 % this block
%                                 kernelA = diff1(blockInd)*gausskernel;
%                                 kernelB = diff2(blockInd)*gausskernel;
%                                 
%                                 % Get the indices in gtGrid to add each
%                                 % kernel
%                                 [tMesh1, gMesh1] = meshgrid(tInd1 + (-floor(gtHeatmapKernelSize/2):floor((gtHeatmapKernelSize - 1)/2)), gInd1 + (-floor(gtHeatmapKernelSize/2):floor((gtHeatmapKernelSize - 1)/2)));
%                                 [tMesh2, gMesh2] = meshgrid(tInd2 + (-floor(gtHeatmapKernelSize/2):floor((gtHeatmapKernelSize - 1)/2)), gInd2 + (-floor(gtHeatmapKernelSize/2):floor((gtHeatmapKernelSize - 1)/2)));
%                                 gridIndsA = sub2ind(size(gtGridA), gMesh1, tMesh1);
%                                 gridIndsB = sub2ind(size(gtGridB), gMesh2, tMesh2);
%                                 
%                                 % Add each kernel to the gtGrid for each stim
%                                 gtGridA(gridIndsA) = kernelA + gtGridA(gridIndsA);
%                                 gtGridB(gridIndsB) = kernelB + gtGridB(gridIndsB);
%                             end
%                             
%                             [gtGridMeshT, gtGridMeshG] = meshgrid(ceil(gtHeatmapKernelSize/2):(ceil(gtHeatmapKernelSize/2) + gtHeatmapResolution - 1));
%                             gtGridTrueInds = sub2ind(size(gtGridA), gtGridMeshG, gtGridMeshT);
%                             gtGridA = gtGridA(gtGridTrueInds);
%                             gtGridB = gtGridB(gtGridTrueInds);
                            
                            hGTHMA = figure;
                            a1 = axes;
                            hold(a1, 'on');
                            colormap(a1, 'jet');
                            colorbar(a1);
                            surf(a1, trueTGridPoints, trueGGridPoints, gtGridAConv', 'edgealpha', 0);
                            xlim([0 15]);
                            ylim([0 50]);
                            xlabel('Duration (ms)');
                            ylabel('Strength (mW/mm^2)');
                            caxis(a1, max(abs(gtGridAConv(:)))*[-1 1]);
                            title('Stimulation A performance');
                            view(2);
                            
                            hGTHMB = figure;
                            a2 = axes;
                            hold(a2, 'on');
                            colormap(a2, 'jet');
                            colorbar(a2);
                            surf(a2, trueTGridPoints, trueGGridPoints, gtGridBConv', 'edgealpha', 0);
                            xlim([0 15]);
                            ylim([0 50]);
                            xlabel('Duration (ms)');
                            ylabel('Strength (mW/mm^2)');
                            caxis(a2, max(abs(gtGridBConv(:)))*[-1 1]);
                            title('Stimulation B performance');
                            view(2);
                        end
                    end
                    
                    %% Ask user for input on where the start and stop times should be
                    if useSection && useGInput
                        [times, ~] = ginput(2);
                        
                        % Check if the user hit enter early (indicating that they want
                        % to finish)
                        if (size(times,1) < 2) || (times(1) == times(2))
                            % If the user hit enter exit the loop using the last choice
                            % (if nothing was chosen, don't save anything)
                            break;
                        else
                            % If the user chose different times, then close all
                            % windows except the performance over time window  (the
                            % one used to make this selection)
                            close all;
                        end
                        
                        
                        % Record the times
                        timeStart = min(times);
                        timeEnd = max(times);
                        haveTimes = true;
                        
                        clipString = sprintf('_%d-%d', round(timeStart*60), round(timeEnd*60));
                    elseif useSection && ~useGInput
                        clipString = sprintf('_%d-%d', round(userTimeStart), round(userTimeEnd));
                    else
                        % Include entire plot
                        timeStart = -Inf;
                        timeEnd = Inf;
                        clipString = '';
                    end
                    
                    % Determine the mask on the plotted data
                    includedWindowed = false(size(potXAxis,1),1);
                    includedWindowed((timeStart <= potXAxis) & (potXAxis < timeEnd)) = true;
                    includedSeq = false(size(adjustedSequenceTimes,2),1);
                    %             included((sequenceTimeAxis(find(includedWindowed, 1)) <= adjustedSequenceTimes) & (adjustedSequenceTimes <= sequenceTimeAxis(find(includedWindowed, 1, 'last')))) = true;
                    includedSeq((timeStart <= adjustedSequenceTimes) & (adjustedSequenceTimes <= timeEnd)) = true;
                    
                    included = false(size(adjustedStimTimes,2),1);
                    %             included((sequenceTimeAxis(find(includedWindowed, 1)) <= adjustedSequenceTimes) & (adjustedSequenceTimes <= sequenceTimeAxis(find(includedWindowed, 1, 'last')))) = true;
                    included((timeStart <= adjustedStimTimes) & (adjustedStimTimes <= timeEnd)) = true;
                    
                    % Mask out the data to be plotted
                    stimTimesTrimmedSeq = stimTimes1(includedSeq,:);
                    %                     adjustedStimTimesTrimmed = adjustedStimTimes(included, :);
                    %                     eR1Trimmed = eRAll1(included,:);
                    %                     eR2Trimmed = eRAll2(included,:);
                    stimTimesTrimmed = stimTimes1(included);
                    adjustedStimTimesTrimmed = adjustedStimTimes(included);
                    timeAxisTrimmed = potXAxis(includedWindowed);
                    markersIndsTrimmed = round(linspace(find(includedWindowed, 1), find(includedWindowed, 1, 'last'), round(numMarkers*(sum(includedWindowed)/length(includedWindowed)))));
                    eR1Trimmed = eRAll1Col(included);
                    eR2Trimmed = eRAll2Col(included);
                    TP1Trimmed = TP1(includedWindowed);
                    TP2Trimmed = TP2(includedWindowed);
                    FA1Trimmed = FA1(includedWindowed);
                    FA2Trimmed = FA2(includedWindowed);
                    indsInResultsDataTrimmed = zeros(size(stimTimesTrimmedSeq, 1), size(stimTimesTrimmedSeq, 2), numUnits);
                    [~, indsInResultsDataTrimmed(:,:,1)] = ismember(stimTimesTrimmedSeq, resultsTimes1);
                    [~, indsInResultsDataTrimmed(:,:,2)] = ismember(stimTimesTrimmedSeq, resultsTimes2);
                    
                    if useTimeXAxis
                        xAxisTrimmed = timeAxisTrimmed;
                    else
                        xAxisTrimmed = includedWindowed;
                    end
                    
                    %% Plot the relevant information
                    if doTrimmedPerfOverTimePlot
                        %% Plot unit performance within boundaries
                        hTPOT = figure;
                        h = zeros(1,4);
                        plot(xAxisTrimmed, TP1Trimmed, TP1LineStr, xAxisTrimmed, TP2Trimmed, TP2LineStr, xAxisTrimmed, FA1Trimmed, FA1LineStr, xAxisTrimmed, FA2Trimmed, FA2LineStr, 'linewidth', plotLineWidth, 'markersize', markerSize);
                        hold on;
                        h(1:4) = plot(a, xAxisTrimmed(markersIndsTrimmed), TP1Trimmed(markersIndsTrimmed), TP1MarkStr, xAxisTrimmed(markersIndsTrimmed), TP2Trimmed(markersIndsTrimmed), TP2MarkStr, xAxisTrimmed(markersIndsTrimmed), FA1Trimmed(markersIndsTrimmed), FA1MarkStr, xAxisTrimmed(markersIndsTrimmed), FA2Trimmed(markersIndsTrimmed), FA2MarkStr, 'linewidth', plotLineWidth, 'markersize', markerSize);
                        legend(h, {'Unit A True Positive', 'Unit B True Positive', 'Unit A False Alarm', 'Unit B False Alarm'}, 'fontsize', legendFontSize, 'location', 'northeast');
                        title(sprintf('t = %dms (n = %d, P[A] = %0.2f, P[B] = %0.2f)', iS, numel(eR1Trimmed), fractionOfTotal(eR1Trimmed), fractionOfTotal(eR2Trimmed)), 'fontsize', plotFontSize);
                        
                        if useTimeXAxis
                            xlabel('Sequence Start Time (minutes)', 'fontsize', plotFontSize);
                        else
                            %                             xlabel('Sequence number', 'fontsize', plotFontSize);
                            xlabel('Stimulation number', 'fontsize', plotFontSize);
                        end
                        
                        ylabel('Response Fraction', 'fontsize', plotFontSize)
                        set(gca, 'fontsize', plotFontSize);
                        ylim([0 1]);
                    end
                    
                    if doProbTrajPlot
                        h = zeros(2,1);
                        tLims = adjustedStimTimesTrimmed([1 end]);
                        
                        % Plot the trajectory through probablity space
                        hPT1 = figure;
                        a1 = axes;
                        colorbar;
                        hPT2 = figure;
                        a2 = axes;
                        colorbar;
                        hold(a1, 'on');
                        hold(a2, 'on');
                        val = timeAxisTrimmed;
                        z = zeros(size(val));
                        
                        axes(a1)
                        h(1) = surface([TP1Trimmed';TP1Trimmed'],[FA2Trimmed';FA2Trimmed'],[z;z],[val;val],'facecol','no','edgecol','interp','linew',2);
                        
                        title(sprintf('t = %dms (n = %d, P[A] = %0.2f, P[B] = %0.2f)', iS, numel(eR1Trimmed), fractionOfTotal(eR1Trimmed), fractionOfTotal(eR2Trimmed)), 'fontsize', plotFontSize);
                        xlabel('A True Positives', 'fontsize', plotFontSize);
                        ylabel('B False Alarms', 'fontsize', plotFontSize)
                        set(gca, 'fontsize', plotFontSize);
                        ylim([0 1]);
                        xlim([0 1]);
                        pbaspect(a1, [1 1 1]);
                        caxis(tLims)
                        
                        %             c2 = [linspace(0,finalVal2,255)' linspace(.8,.8,255)' linspace(0,finalVal2,255)'];
                        %             colormap(a,c2);
                        axes(a2);
                        h(2) = surface([TP2Trimmed';TP2Trimmed'],[FA1Trimmed';FA1Trimmed'],[z;z],[val;val],'facecol','no','edgecol','interp','linew',2);
                        
                        title(sprintf('t = %dms (n = %d, P[A] = %0.2f, P[B] = %0.2f)', iS, numel(eR1Trimmed), fractionOfTotal(eR1Trimmed), fractionOfTotal(eR2Trimmed)), 'fontsize', plotFontSize);
                        xlabel('B True Positives', 'fontsize', plotFontSize);
                        ylabel('A False Alarms', 'fontsize', plotFontSize)
                        set(gca, 'fontsize', plotFontSize);
                        ylim([0 1]);
                        xlim([0 1]);
                        pbaspect(a2, [1 1 1]);
                        caxis(tLims)
                    end
                    
                    if thisDoTracesPlot || thisDoCompareTracesPlot
                        % If we are going to be plotting the traces
                        % themselves, then we should get all of the
                        % relevant information from the TDT Tank
                        
                        % Plot both aligned and non-aligned
                        for alignInd = 1:2
                            alignTraces = logical(mod(alignInd,2)); % Should the traces be aligned to their spike/peak?
                            
                            if alignTraces
                                alterString = ', Aligned';
                            else
                                alterString = '';
                            end
                            
                            % Set up traces axes
                            allAxesSpike = zeros(numCases, numChansPerTet);
                            allAxesNoSpike = zeros(numCases, numChansPerTet);
                            allAxesCompleteSpike = zeros(numCases, numChansPerTet);
                            allAxesCompleteNoSpike = zeros(numCases, numChansPerTet);
                            minMaxCT = [Inf -Inf];
                            minMaxTP = [Inf -Inf];
                            minMaxCompleteTP = [Inf -Inf];
                            
                            if thisDoCompareTracesPlot
                                % Prepare variables to store data
                                traceSegmentNums = cell(numUnits, 1); % A cell for each unit, each cell containing a vector with the segment numbers of each trace
                                
                                % Prepare stim times for reference
                                adjustedStimTimesTrimmedT = adjustedStimTimesTrimmed'; % Transpose stimTimesTrimmed, so that column indexing gives the proper order
                                adjustedStimTimesTrimmedOrdered = adjustedStimTimesTrimmedT(:);
                            end
                            
                            % Get stim locations in resultsData for both
                            allTraces = cell(numUnits, 1); % TODO: Record all traces from each channel of the tetrode, for both units
                            
                            % TESTING
%                             usedMax = false(numTraces, numUnits);
                            % TESTING
                            for unitNum = 1:numUnits
                                thisInds = indsInResultsDataTrimmed(:,:,unitNum)'; % Transpose thisInds as it comes out of the matrix...
                                thisInds = thisInds(:); % ...so that it can be column indexed along the correct dimension.
                                
                                thisTetNum = thisTetNums(unitNum); % Get the tetrode number for this unit
                                thisTetChans = (thisTetNum - 1)*numChansPerTet + (1:numChansPerTet);
                                
                                switch unitNum
                                    case 1
                                        tEnds1 = [0 max([lengthWaveformPart N1.triggerTimespan(thisInds(1),2)])];
                                        tEnds = tEnds1;
                                        nS = N1;
                                    case 2
                                        tEnds2 = [0 max([lengthWaveformPart N2.triggerTimespan(thisInds(1),2)])];
                                        tEnds = tEnds2;
                                        nS = N2;
                                end
                                
                                numTraces = length(thisInds);
                                
                                % Initialize the allTraces cell
                                for chNum = 1:numChansPerTet
                                    allTraces{unitNum} = cell(numTraces, 2);
                                end
                                
                                %                                 if thisDoCompareTracesPlot
                                %                                     traceSegmentNums{unitNum} = zeros(length(thisInds), 1);
                                %                                 end
                                
                                for traceNum = 1:numTraces
                                    t = thisInds(traceNum);
                                    thisTraceSpike = logical(nS.resultsData(t, 3));
                                    
                                    % Get the voltage trace
                                    vT = thisStimResponses{traceNum, 1}(:, thisTetChans); % Get just the traces (This is an Lx4 matrix, where L is the length of the trace, and 4 is the number of channels per tetrode)
                                    lengthEntireTrace = size(vT, 1);
                                    
                                    % Get the time-stamps of each sample
                                    tDataOriginalRaw = thisStimResponses{traceNum, 2}; % Get the time series for the entire 50ms long trace
                                    tDataOriginal = (tDataOriginalRaw - (tDataOriginalRaw(1)))*1000; % Make the first sample occur at time 0, and convert the time to ms
                                    indsCroppedData = tEnds(1) <= tDataOriginal & tDataOriginal <= tEnds(2);
                                    indsCroppedPCA = (tEnds(1) + thisPCACodeDelay) <= tDataOriginal & tDataOriginal <= (tEnds(2) + thisPCACodeDelay);
                                    firstInd = find(indsCroppedData, 1) - 1; % The index of the first sample included in the trigger timespan, relative to the entire trace
                                    firstIndPCA = find(indsCroppedPCA, 1) - 1; % The index of the first sample included in the trigger timespan for PCA, relative to the entire trace
                                    tData = tDataOriginal(indsCroppedData);
                                    lengthTrace = length(tData);
                                    traceInds = 1:lengthTrace;
                                    
                                    
                                    %                                     if thisDoCompareTracesPlot
                                    %                                         traceSegmentNums{unitNum}(traceNum) = find(segmentTimeStart <= adjustedStimTimesTrimmedOrdered(traceNum), 1, 'last'); % Which segment of the trial does this trace fall into?
                                    %                                     end
                                    
                                    if alignTraces
                                        if thisTraceSpike
                                            %                                             spikeHitInd = find(nS.pcaSortCodes{t}(indsCroppedPCA) == 1, 1); % The index at which a spike is detected (adjusted for the fact that there is a delay between a spike and its PCA code)
                                            %                                             %                                                 spikeHitInd = spikeHitInd + firstIndPCA;
                                            %                                             spikeHitInd = spikeHitInd + firstInd;
                                            
                                            % spikeHitInd = find(nS.pcaSortCodes{t} == 1, 1) + firstInd - firstIndPCA;
                                            
                                            % Assuming that something went
                                            % wonky with spike sorting,
                                            % use the code as a guideline
                                            codeHitInd = find(nS.pcaSortCodes{t} == 1, 1) - firstIndPCA;
                                            searchRegion = codeHitInd + (-findMaxRadius:findMaxRadius);
                                            searchRegion(searchRegion <= 0 | lengthTrace < searchRegion) = [];
                                            if ~isempty(searchRegion)
                                                searchRegionFirstInd = searchRegion(1);
                                                [maxesInSearchRegion, maxIndsInSearchRegion] = max(vT(searchRegion, :));
                                                [~, maxSpikeInSRIndInd] = max(maxesInSearchRegion);
                                                
                                                spikeHitInd = (maxIndsInSearchRegion(maxSpikeInSRIndInd) + searchRegionFirstInd - 1) + firstInd;
                                            else
                                                spikeHitInd = [];
                                            end
                                        end
                                        
                                        if ~thisTraceSpike || isempty(spikeHitInd)
                                            % If this trace did not have a
                                            % spike, or it DID have a spike and
                                            % no online sortcode was found (it
                                            % was an offline sorted trace),
                                            % find the location of the max
                                            % value of all channels
                                            [maxVals, allSpikeHitInds] = max(vT(indsCroppedData, :)); % Simply align all of the non-spike data around its max voltage location
                                            %                                             [~, maxSpikeHitIndInd] = max(maxVals);
                                            maxSpikeHitIndInd = alignChannel;
                                            spikeHitInd = allSpikeHitInds(maxSpikeHitIndInd) + firstInd;
                                            
%                                             usedMax(traceNum, unitNum) = true;
                                        end
                                        
                                        if ~isempty(spikeHitInd)% && (spikeHitInd<=length(tData))
                                            % If a spike was found for this trace, align the time
                                            % series to it
                                            traceInds = traceInds + spikeHitInd - round(lengthTrace/2) + (firstInd);
                                            
                                            %                             tData = tData - tData(spikeHitInd); % Subtract the spike time from the time-series to align
                                        else
                                            spikeHitInd = nan;
                                        end
                                        
                                        tDataAdjust = tData(round(lengthTrace/2));
                                        
%                                         % TESTING
%                                         traceInds(traceInds > lengthTrace) = 0; % Zero values will simply be not used later on
%                                         % TESTING
%                                         
                                    else
                                        tDataAdjust = tData(1);
                                    end
                                    
                                    %                                     if useFilteredTraces
                                    %                                         vT = nS.voltageTraces{t}; % TODO: whooooboy...going to have to load in the TDT file first, THEN plot all of the traces.  Perhaps check to see if convertTankToNTT has been run, and/or if the save file from that script exists?  If not, just load in the data from the tetrode of interest to save time/memory
                                    %                                     else
                                    %                                         % Spike detection will be done on filtered
                                    %                                         % data, but non-filtered may be displayed if
                                    %                                         % desired
                                    %                                         vT = nS.voltageTracesRaw{t};
                                    %                                     end
                                    
%                                     allTraces{unitNum}{traceNum, 1} = convToMicroV*[nan(sum(0 >= traceInds), numChansPerTet); vT(traceInds(0 < traceInds & traceInds <= lengthEntireTrace), :); nan(sum(lengthEntireTrace < traceInds), numChansPerTet)];
                                    allTraces{unitNum}{traceNum, 1} = convToMicroV*[nan(sum(0 >= traceInds), numChansPerTet); vT(traceInds(0 < traceInds & traceInds <= lengthTrace), :); nan(sum(lengthTrace < traceInds), numChansPerTet)];
                                    
                                    allTraces{unitNum}{traceNum, 2} = tData - tDataAdjust;
                                end
                                
                            end
                            
                            % Prepare the plot figures and styles
                            if thisDoTracesPlot
                                if alignTraces
                                    hTrSpkalgn(1) = figure;
                                    hTrSpkalgn(2) = figure;
                                    hTrSpkalgn(3) = figure;
                                    hTrSpkalgn(4) = figure;
                                    hTrNoSpkalgn(1) = figure;
                                    hTrNoSpkalgn(2) = figure;
                                    hTrNoSpkalgn(3) = figure;
                                    hTrNoSpkalgn(4) = figure;
                                    hTrCmpSpkalgn(1) = figure;
                                    hTrCmpSpkalgn(2) = figure;
                                    hTrCmpNoSpkalgn(1) = figure;
                                    hTrCmpNoSpkalgn(2) = figure;
                                    
                                    hTrSpk = hTrSpkalgn;
                                    hTrNoSpk = hTrNoSpkalgn;
                                    hTrCmpSpk = hTrCmpSpkalgn;
                                    hTrCmpNoSpk = hTrCmpNoSpkalgn;
                                    
                                    lineStyle = '-';
                                    lineWidth = .1;
                                else
                                    hTrSpkna(1) = figure;
                                    hTrSpkna(2) = figure;
                                    hTrSpkna(3) = figure;
                                    hTrSpkna(4) = figure;
                                    hTrNoSpkna(1) = figure;
                                    hTrNoSpkna(2) = figure;
                                    hTrNoSpkna(3) = figure;
                                    hTrNoSpkna(4) = figure;
                                    hTrCmpSpkna(1) = figure;
                                    hTrCmpSpkna(2) = figure;
                                    hTrCmpNoSpkna(1) = figure;
                                    hTrCmpNoSpkna(2) = figure;
                                    
                                    hTrSpk = hTrSpkna;
                                    hTrNoSpk = hTrNoSpkna;
                                    hTrCmpSpk = hTrCmpSpkna;
                                    hTrCmpNoSpk = hTrCmpNoSpkna;
                                    
                                    lineStyle = '--';
                                    lineWidth = .1;
                                end
                            end
                            
                            if thisDoCompareTracesPlot
                                if alignTraces
                                    halgnCT = zeros(4,numCompareSegments);
                                    
                                    halgnSpkCTAll(1) = figure;
                                    halgnSpkCTAll(2) = figure;
                                    halgnNoSpkCTAll(1) = figure;
                                    halgnNoSpkCTAll(2) = figure;
                                    hSpkCTAll = halgnSpkCTAll;
                                    hNoSpkCTAll = halgnNoSpkCTAll;
                                else
                                    hnaCT = zeros(4,numCompareSegments);
                                    
                                    hnaSpkCTAll(1) = figure;
                                    hnaSpkCTAll(2) = figure;
                                    hnaNoSpkCTAll(1) = figure;
                                    hnaNoSpkCTAll(2) = figure;
                                    
                                    hSpkCTAll = hnaSpkCTAll;
                                    hNoSpkCTAll = hnaNoSpkCTAll;
                                end
                                suptitle(sprintf('t = %dms%s, All', iS, alterString));
                                
                                hCT = zeros(1,numCompareSegments);
                                for segNum = 1:numCompareSegments
                                    % For each segment, make four figures: one for A and
                                    % one for B, with spikes and non-spikes
                                    % (showing all 4 channels)
                                    if alignTraces
                                        halgnCT(1, segNum) = figure;
                                        halgnCT(2, segNum) = figure;
                                        halgnCT(3, segNum) = figure;
                                        halgnCT(4, segNum) = figure;
                                        hCT(1, segNum) = halgnCT(1, segNum);
                                        hCT(2, segNum) = halgnCT(2, segNum);
                                        hCT(3, segNum) = halgnCT(3, segNum);
                                        hCT(4, segNum) = halgnCT(4, segNum);
                                        
                                    else
                                        hnaCT(1, segNum) = figure;
                                        hnaCT(2, segNum) = figure;
                                        hnaCT(3, segNum) = figure;
                                        hnaCT(4, segNum) = figure;
                                        hCT(1, segNum) = hnaCT(1, segNum);
                                        hCT(2, segNum) = hnaCT(2, segNum);
                                        hCT(3, segNum) = hnaCT(3, segNum);
                                        hCT(4, segNum) = hnaCT(4, segNum);
                                    end
                                end
                                aCT = zeros(numCases, numCompareSegments, numChansPerTet);
                                aCTAll = zeros(numCases, numChansPerTet);
                            end
                            
                            for i = 1:numCases
                                switch i
                                    case {1, 3}
                                        % Looking at Unit 1's responses
                                        thisUnitStr = 'A';
                                        c = 'b';
                                        
                                        % Unit A
                                        thisSequenceIndInResultsData = indsInResultsDataTrimmed(:,:,1);
                                        %                                         thisTimeAxis = timeAxis1;
                                        thisResults = sRCol1(included);
                                        thisTraces = allTraces{1};
                                        tEnds = tEnds1;
                                        
                                        if thisDoCompareTracesPlot
                                            thisHSpkCTAll = hSpkCTAll(1);
                                            thisHNoSpkCTAll = hNoSpkCTAll(1);
                                        end
                                    case {2, 4}
                                        % Looking at Unit 2's responses
                                        thisUnitStr = 'B';
                                        c = 'r';
                                        
                                        % Unit B
                                        thisSequenceIndInResultsData = indsInResultsDataTrimmed(:,:,2);
                                        %                                         thisTimeAxis = timeAxis2;
                                        thisResults = sRCol2(included);
                                        thisTraces = allTraces{2};
                                        tEnds = tEnds2;
                                        
                                        if thisDoCompareTracesPlot
                                            thisHSpkCTAll = hSpkCTAll(2);
                                            thisHNoSpkCTAll = hNoSpkCTAll(2);
                                        end
                                end
                                
                                doCmpFigs = i <= 2; % Should the "complete" figures be plotted (that group all of the spikes/no spikes of a single unit together, instead of separating by expected result)
                                
                                thisHTrSpk = hTrSpk(i);
                                thisHTrNoSpk = hTrNoSpk(i);
                                if doCmpFigs
                                    thisHTrCmpSpk = hTrCmpSpk(i);
                                    thisHTrCmpNoSpk = hTrCmpNoSpk(i);
                                end
                                
                                thisResultsT = thisResults';
                                thisResults = thisResultsT(:); % Get a column vector version of thisResults, because using colon operator on it before transposing would list them the wrong way
                                
                                switch i
                                    case {1, 2}
                                        expectedStr = 'A';
                                        % Looking at Stim A's responses
                                        thisExpected = eR1Trimmed;
                                    case {3, 4}
                                        expectedStr = 'B';
                                        % Looking at Stim B's reponses
                                        thisExpected = eR2Trimmed;
                                end
                                
                                switch i
                                    case {1, 4}
                                        match = true;
                                        spikeStr = 'Spike';
                                        
                                        if doCompareTracesPlot
                                            thisHCTAll = thisHSpkCTAll;
                                        end
                                    case {2, 3}
                                        match = false;
                                        spikeStr = 'No Spike';
                                        
                                        if doCompareTracesPlot
                                            thisHCTAll = thisHNoSpkCTAll;
                                        end
                                end
                                
                                % Adjust expected matrix into a column
                                thisExpectedT = thisExpected';
                                thisExpected = thisExpectedT(:); % Get proper columnization
                                
                                if thisDoTracesPlot
                                    tracesSpike = thisTraces(logical(thisExpected) & logical(thisResults),:);
                                    tracesNoSpike = thisTraces(logical(thisExpected) & logical(~thisResults),:);
                                    
                                    if doCmpFigs
                                        tracesCompleteSpike = thisTraces(logical(thisResults),:);
                                        tracesCompleteNoSpike = thisTraces(logical(~thisResults),:);
                                    end
                                    
                                    
                                    % Only take up to the maximum required number of traces
                                    numTracesSpike = size(tracesSpike,1); % Number of traces with a threshold crossing
                                    numTracesNoSpike = size(tracesNoSpike,1); % Number of traces with a threshold crossing
                                    
                                    % Plot the spike traces
                                    %                                     subplotPositionSpike = 2*(mod(match + 1, 2) + 1) - 1;
                                    if numTracesSpike > 0
                                        for chNum = 1:numChansPerTet
                                            figure(thisHTrSpk);
                                            allAxesSpike(i, chNum) = subplot(2,2,chNum);
                                            hold(allAxesSpike(i, chNum), 'on');
                                            
                                            if doCmpFigs
                                                figure(thisHTrCmpSpk);
                                                allAxesCompleteSpike(i, chNum) = subplot(2, 2, chNum);
                                                hold(allAxesCompleteSpike(i, chNum), 'on');
                                            end
                                            for traceNum = 1:numTracesSpike
                                                plot(allAxesSpike(i, chNum), tracesSpike{traceNum, 2}, tracesSpike{traceNum, 1}(:, chNum), sprintf('%s%s', c, lineStyle), 'linewidth', lineWidth);
                                                
                                                % Get minimum and maximum of traces
                                                minMaxTP = [min([minMaxTP(1); tracesSpike{traceNum, 1}(:, chNum)]) max([minMaxTP(2); tracesSpike{traceNum, 1}(:, chNum)])];
                                                
                                                if doCmpFigs
                                                    plot(allAxesCompleteSpike(i, chNum), tracesCompleteSpike{traceNum, 2}, tracesCompleteSpike{traceNum, 1}(:, chNum), sprintf('%s%s', c, lineStyle), 'linewidth', lineWidth);
                                                    minMaxCompleteTP = [min([minMaxCompleteTP(1); tracesCompleteSpike{traceNum, 1}(:, chNum)]) max([minMaxCompleteTP(2); tracesCompleteSpike{traceNum, 1}(:, chNum)])];
                                                end
                                            end
                                            
                                            title(sprintf('Ch %d', chNum));
                                            if chNum == 1 || chNum == 3
                                                % y-axis
                                                ylabel('Potential (µV)');
                                            end
                                            
                                            if chNum == 3 || chNum == 4
                                                % x-axis
                                                xlabel('Time (ms)');
                                            end
                                            
                                            if doCmpFigs
                                                a = allAxesCompleteSpike(i, chNum);
                                                
                                                title(a, sprintf('Ch %d', chNum));
                                                if chNum == 1 || chNum == 3
                                                    % y-axis
                                                    ylabel(a, 'Potential (µV)');
                                                end
                                                
                                                if chNum == 3 || chNum == 4
                                                    % x-axis
                                                    xlabel(a, 'Time (ms)');
                                                end
                                            end
                                        end
                                    end
                                    
                                    figure(thisHTrSpk);
                                    suptitle(sprintf('Unit %s, Expected %s, Spike, n = %d', thisUnitStr, expectedStr, numTracesSpike));
                                    figure(thisHTrCmpSpk);
                                    suptitle(sprintf('Unit %s, Spike, n = %d', thisUnitStr, numTracesSpike));
                                    %                                     if subplotPositionSpike == 3
                                    %                                         xlabel('Time (ms)');
                                    %                                     end
                                    %                                     ylabel('Potential (µV)');
                                    
                                    % Plot the no spike traces
                                    %                                     subplotPositionNoSpike = subplotPositionSpike + 1;
                                    if numTracesNoSpike > 0
                                        for chNum = 1:numChansPerTet
                                            figure(thisHTrNoSpk);
                                            allAxesNoSpike(i, chNum) = subplot(2,2,chNum);
                                            hold(allAxesNoSpike(i, chNum), 'on');
                                            
                                            if doCmpFigs
                                                figure(thisHTrCmpNoSpk);
                                                allAxesCompleteNoSpike(i, chNum) = subplot(2,2,chNum);
                                                hold(allAxesCompleteNoSpike(i, chNum), 'on');
                                            end
                                            for traceNum = 1:numTracesNoSpike
                                                plot(allAxesNoSpike(i, chNum), tracesNoSpike{traceNum, 2}, tracesNoSpike{traceNum, 1}(:, chNum), sprintf('%s%s', c, lineStyle), 'linewidth', lineWidth);
                                                
                                                % Get minimum and maximum of traces
                                                minMaxTP = [min([minMaxTP(1); tracesNoSpike{traceNum, 1}(:, chNum)]) max([minMaxTP(2); tracesNoSpike{traceNum, 1}(:, chNum)])];
                                                
                                                if doCmpFigs
                                                    plot(allAxesCompleteNoSpike(i, chNum), tracesCompleteNoSpike{traceNum, 2}, tracesCompleteNoSpike{traceNum, 1}(:, chNum), sprintf('%s%s', c, lineStyle), 'linewidth', lineWidth);
                                                    minMaxCompleteTP = [min([minMaxCompleteTP(1); tracesCompleteNoSpike{traceNum, 1}(:, chNum)]) max([minMaxCompleteTP(2); tracesCompleteNoSpike{traceNum, 1}(:, chNum)])];
                                                end
                                            end
                                            
                                            title(sprintf('Ch %d', chNum));
                                            if chNum == 1 || chNum == 3
                                                % y-axis
                                                ylabel('Potential (µV)');
                                            end
                                            
                                            if chNum == 3 || chNum == 4
                                                % x-axis
                                                xlabel('Time (ms)');
                                            end
                                            
                                            if doCmpFigs
                                                a = allAxesCompleteNoSpike(i, chNum);
                                                
                                                title(a, sprintf('Ch %d', chNum));
                                            if chNum == 1 || chNum == 3
                                                % y-axis
                                                ylabel(a, 'Potential (µV)');
                                            end
                                            
                                            if chNum == 3 || chNum == 4
                                                % x-axis
                                                xlabel(a, 'Time (ms)');
                                            end
                                            end
                                        end
                                    end
                                    
                                    figure(thisHTrNoSpk);
                                    suptitle(sprintf('Unit %s, Expected %s, No Spike, n = %d', thisUnitStr, expectedStr, numTracesNoSpike));
                                    figure(thisHTrCmpNoSpk);
                                    suptitle(sprintf('Unit %s, No Spike, n = %d', thisUnitStr, numTracesNoSpike));
                                    
                                    %                                     title(sprintf('Expected %s, No Spike, n = %d', str, newNumTracesNoSpike));
                                    %                                     if subplotPositionNoSpike == 4
                                    %                                         xlabel('Time (ms)');
                                    %                                     end
                                end
                                
                                if thisDoCompareTracesPlot
                                    subplotPositionOriginal = mod(-i + 1, numCases) + 1;
                                    
                                    %% Plot individual segments
                                    for segNum = 1:numCompareSegments
                                        % Calculate which traces are
                                        % included in this segment
                                        thisTraceSegmentBounds = [((segNum - 1)*numRunsPerCompareSegment) (segNum*numRunsPerCompareSegment)]*numSequencesPerRun*numStimsPerSequence;
                                        thisTraceSegmentNums = ((thisTraceSegmentBounds(1) + 1):thisTraceSegmentBounds(2));
                                        thisTraceSegmentLogicals = false(size(thisTraces, 1), 1);
                                        thisTraceSegmentLogicals(thisTraceSegmentNums) = true;
                                        
                                        % Traces for expected A stims
                                        traces = thisTraces(xor(logical(thisResults), ~match) & thisTraceSegmentLogicals,:); % xor match with the results so that match toggles the spikes and the non-spikes (match = true, don't toggle)
                                        numNewTraces = size(traces,1);
                                        
                                        % Go through each channel in the
                                        % tetrode
                                        figure(hCT(i, segNum));
                                        for chNum = 1:numChansPerTet
                                            aCT(i,segNum, chNum) = subplot(2,2,chNum);
                                            
                                            if ~isempty(traces)
                                                % Preprocess the traces
                                                thisTracesMat = zeros(size(traces{1, 1}, 1), numNewTraces);
                                                for traceNum = 1:numNewTraces
                                                    thisTracesMat(:, traceNum) = traces{traceNum, 1}(:, chNum);
                                                end
                                                
                                                % Plot the expected A traces
                                                % Original
                                                hold(aCT(i,segNum, chNum), 'on');
                                                if numNewTraces > 0
                                                    plot(aCT(i,segNum, chNum), traces{1, 2}, thisTracesMat, sprintf('%s:', c));
                                                end
                                                
                                                if alignTraces
                                                    % Include an average waveform
                                                    avgTrace = nanmean(thisTracesMat, 2);
                                                    plot(aCT(i,segNum, chNum), traces{1, 2}, avgTrace, 'k-', 'linewidth', 2);
                                                end
                                            end
                                            
                                            %                                             title(sprintf('Unit %s, %s, n = %d', thisUnitStr, spikeStr, numNewTraces));
                                            title(sprintf('Ch %d', chNum));
                                            if chNum == 3 || chNum == 4
                                                xlabel('Time (ms)');
                                            end
                                            if chNum == 1 || chNum == 3
                                                ylabel('Potential (µV)');
                                            end
                                        end
                                        
                                        suptitle(sprintf('Unit %s, segment %d, %s%s', thisUnitStr, segNum, spikeStr, alterString));
                                    end
                                    
                                    %% Plot all segments together
                                    % Traces for expected A stims
                                    traces = thisTraces(xor(logical(thisResults), ~match),:); % xor match with the results so that match toggles the spikes and the non-spikes (match = true, don't toggle)
                                    numNewTraces = size(traces,1);
                                    
                                    figure(thisHCTAll)
                                    for chNum = 1:numChansPerTet
                                        aCTAll(i, chNum) = subplot(2,2,chNum);
                                        if ~isempty(traces)
                                            thisTracesMat = zeros(size(traces{1, 1}, 1), numNewTraces);
                                            for traceNum = 1:numNewTraces
                                                thisTracesMat(:, traceNum) = traces{traceNum, 1}(:, chNum);
                                                
                                                % Get minimum and maximum of traces
                                                if match
                                                    minMaxCT = [min([minMaxCT(1); traces{traceNum, 1}(:, chNum)]) max([minMaxCT(2); traces{traceNum, 1}(:, chNum)])];
                                                end
                                            end
                                            
                                            % Plot the expected A traces
                                            % Original
                                            hold(aCTAll(i, chNum), 'on');
                                            if numNewTraces > 0
                                                plot(aCTAll(i, chNum), traces{1, 2},thisTracesMat, sprintf('%s:', c));
                                            end
                                            
                                            if alignTraces
                                                % Include an average waveform
                                                avgTrace = nanmean(thisTracesMat, 2);
                                                plot(aCTAll(i, chNum), traces{1, 2}, avgTrace, 'k-', 'linewidth', 2);
                                            end
                                        end
                                        
                                        %                                         title(sprintf('Unit %s, %s, n = %d', thisUnitStr, spikeStr, numNewTraces));
                                        title(sprintf('Ch %d', chNum));
                                        if chNum == 3 || chNum == 4
                                            xlabel('Time (ms)');
                                        end
                                        if chNum == 1 || chNum == 3
                                            ylabel('Potential (µV)');
                                        end
                                    end
                                    
                                    suptitle(sprintf('Unit %s, All, %s%s', thisUnitStr, spikeStr, alterString));
                                end
                            end
                            
                            % Set all axis limits properly
                            %                             if thisDoTracesPlot
                            if alignTraces
                                % If the traces are aligned, then
                                % zoom into the waveform
                                tracesPlotXLim = alignedTraceLimits;
                            else
                                tracesPlotXLim = [tEnds(1) tEnds(2)];
                            end
                            %                             end
                            
                            for i = 1:numCases
                                for chNum = 1:numChansPerTet
                                    if thisDoTracesPlot
                                        try
                                            set(allAxesSpike(i, chNum), 'yLim', 1.15*minMaxTP, 'xlim', tracesPlotXLim);
                                            
                                            if i <= 2
                                                set(allAxesCompleteSpike(i, chNum), 'yLim', 1.15*minMaxCompleteTP, 'xlim', tracesPlotXLim);
                                            end
                                        end
                                        try
                                            set(allAxesNoSpike(i, chNum), 'yLim', 1.15*minMaxTP, 'xlim', tracesPlotXLim);
                                            
                                            if i <= 2
                                                set(allAxesCompleteNoSpike(i, chNum), 'yLim', 1.15*minMaxCompleteTP, 'xlim', tracesPlotXLim);
                                            end
                                        end
                                    end
                                    
                                    if thisDoCompareTracesPlot
                                        for segNum = 1:numCompareSegments
                                            try
                                                set(aCT(i,segNum, chNum), 'yLim', 1.15*minMaxCT, 'xlim', tracesPlotXLim);
                                            end
                                        end
                                        try
                                            set(aCTAll(i, chNum), 'yLim', 1.15*minMaxCT, 'xlim', tracesPlotXLim);
                                        end
                                    end
                                end
                            end
                        end
                    end
                    
                    if doOverviewPlot
                        %% Calculate the stim responses for [A] and [B]
                        % Prepare for overview plot calculation
                        allPrevStimOrdersStr = [];
                        stimOrderN = zeros(numStimOrdersAll, numUnits);
                        TP1AllTrimmed = cell(1, numStimOrdersAll);
                        TP2AllTrimmed = cell(1, numStimOrdersAll);
                        FA1AllTrimmed = cell(1, numStimOrdersAll);
                        FA2AllTrimmed = cell(1, numStimOrdersAll);
                        
                        stimOrderInd = 1;
                        for stimOrderLength = 0:numLengths
                            % Go through all lengths of pre-stim orders (including 0, as baseline)
                            % Build the stim orders that will be checked
                            if stimOrderLength ~= 0
                                prevStimOrders = dec2bin(0:(2^stimOrderLength) - 1) - '0'; % All previous stimulations orders to be checked (1 is unit A, 0 is unit B)
                                numStimOrders = size(prevStimOrders, 1);
                                
                                allPrevStimOrdersStr = [allPrevStimOrdersStr;cellstr(num2str(prevStimOrders))];
                            else
                                prevStimOrders = []; % No history is being considered, so the stim order is just the stim being analyzed
                                numStimOrders = 1;
                                
                                allPrevStimOrdersStr = [allPrevStimOrdersStr;{''}];
                            end
                            
                            % Find all locations in the normal expectedResults matrix
                            % where this ordering appears (nested loops are a horrible
                            % thing, but I can't get xcorr2 or any other viable
                            % options to work).
                            for stimOrderNum = 1:numStimOrders
                                if ~isempty(prevStimOrders)
                                    thisPrevOrder = prevStimOrders(stimOrderNum, :);
                                else
                                    thisPrevOrder = [];
                                end
                                eRHistory1 = [];
                                eRHistory2 = [];
                                resultsHistory1 = [];
                                resultsHistory2 = [];
                                
                                %% For each unit, check the order history leading up to a stimulation of that unit
                                for neuronNum = 1:numUnits
                                    %                                     includedER = eRAll1Col(included); % Expected results included in the time-frame
                                    includedER = eRAll1(includedSeq,:); % Expected results included in the time-frame
                                    
                                    thisStimOrderLocations = [];
                                    thisStimOrder = [thisPrevOrder logical(mod(neuronNum, numUnits))]; % This stim order is the previous order combined with a final stim, either A or B.  All stim orders are grouped by their PREVIOUS stim orders, so that TP/FA analysis can be done on them (by using both A- and B- stims in the final stim slot)
                                    for sequenceNum = 1:length(includedER)
                                        newLocs = strfind(includedER(sequenceNum,:), thisStimOrder);
                                        numNewLocs = length(newLocs);
                                        if numNewLocs > 0
                                            thisStimOrderLocations = [thisStimOrderLocations; [repmat(sequenceNum, numNewLocs, 1) (newLocs + stimOrderLength)']]; % A matrix which holds the sequence (in run) and slot number of the stimulation to be analyzed
                                        end
                                    end
                                    
                                    % Get resultsData
                                    stimTimesInds = sub2ind(size(stimTimesTrimmedSeq), thisStimOrderLocations(:,1), thisStimOrderLocations(:,2));
                                    [~, resultsDataInds] = ismember(stimTimesTrimmedSeq(stimTimesInds), resultsTimes1); % The indices in resultsData of each relevant stimulation
                                    
                                    allResults1 = resultsData1(resultsDataInds,3); % The results of each stimulation
                                    thisFinalStimER1 = repmat(thisStimOrder(end), size(allResults1, 1), 1); % The expected result of the stim to be analyzed (the one at the end of this stimulation order)
                                    eRHistory1 = logical([eRHistory1;thisFinalStimER1]);
                                    resultsHistory1 = [resultsHistory1;allResults1];
                                    allResults2 = resultsData2(resultsDataInds,3); % The results of each stimulation
                                    thisFinalStimER2 = repmat(~thisStimOrder(end), size(allResults2, 1), 1); % The expected result of the stim to be analyzed (the one at the end of this stimulation order)
                                    eRHistory2 = logical([eRHistory2;thisFinalStimER2]);
                                    resultsHistory2 = [resultsHistory2;allResults2];
                                end
                                
                                %                         TPHistory1 = resultsHistory1 & eRHistory1;
                                %                         TPHistory2 = resultsHistory2 & eRHistory2;
                                %                         FAHistory1 = resultsHistory1 & ~eRHistory1;
                                %                         FAHistory2 = resultsHistory2 & ~eRHistory2;
                                
                                TP1AllTrimmed{stimOrderInd} = resultsHistory1(eRHistory1); % P{a|a} (One half of these stimulations were supposed to stimulate this unit, so the sum of TP's gets divided by half the number of analyzed stims)
                                TP2AllTrimmed{stimOrderInd} = resultsHistory2(eRHistory2); % P{b|b} (One half of these stimulations were supposed to stimulate this unit, so the sum of TP's gets divided by half the number of analyzed stims)
                                FA1AllTrimmed{stimOrderInd} = resultsHistory1(~eRHistory1); % P{a|b} (One half of these stimulations were supposed to stimulate this unit, so the sum of FA's gets divided by half the number of analyzed stims)
                                FA2AllTrimmed{stimOrderInd} = resultsHistory2(~eRHistory2); % P{b|a} (One half of these stimulations were supposed to stimulate this unit, so the sum of FA's gets divided by half the number of analyzed stims)
                                
                                % Get the number of data points per stim order
                                stimOrderN(stimOrderInd, 1) = sum(eRHistory1);
                                stimOrderN(stimOrderInd, 2) = sum(eRHistory2);
                                
                                stimOrderInd = stimOrderInd + 1;
                            end
                        end
                        
                        TP1Av = cellMean(TP1AllTrimmed)';
                        TP1Er = cellSTD(TP1AllTrimmed);
                        TP2Av = cellMean(TP2AllTrimmed)';
                        TP2Er = cellSTD(TP2AllTrimmed);
                        FA1Av = cellMean(FA1AllTrimmed)';
                        FA1Er = cellSTD(FA1AllTrimmed);
                        FA2Av = cellMean(FA2AllTrimmed)';
                        FA2Er = cellSTD(FA2AllTrimmed);
                        
                        if useStErr
                            % Convert to standard error
                            % Orders
                            TP1Er = TP1Er./stimOrderN(:,1)';
                            TP2Er = TP2Er./stimOrderN(:,2)';
                            FA1Er = FA1Er./stimOrderN(:,1)';
                            FA2Er = FA2Er./stimOrderN(:,2)';
                        end
                        
                        ordersLabels = strrep(strrep(allPrevStimOrdersStr, '1', 'A'), '0', 'B');
                        ordersLabelsWithN = strcat({'('}, strtrim(cellstr(num2str(stimOrderN))), {'), ['}, ordersLabels, {']'});
                        
                        % Make a common x-axis
                        groupwidth = min(0.8, numCases/(numCases+1.5)); % Needed to align errorbars to bar graph
                        errorBarPositions = repmat(1:length(TP1Av),numCases,1) - groupwidth/2 + (2*repmat((1:numCases)',1,length(TP1Av)) -1) * groupwidth / (2*numCases);  % Based on barweb.m by Bolu Ajiboye from MATLAB File Exchange, via MathWorks Support Team on Mathworks
                        
                        % Produce string if the inter-stim period is the same
                        if ~isempty(iS)
                            ISString = sprintf(' (inter-stim period = %dms)', iS);
                        else
                            ISString = '';
                        end
                        
                        % Make a combined plot
                        hOv = figure;
                        a = axes;
                        colormap(a, [0 0 1;1 .4 .4;1 0 0;.5 .5 1]);
                        hold(a, 'on');
                        l = zeros(1,2*numCases);
                        l(1:4) = bar(a, [TP1Av FA2Av TP2Av FA1Av], 1);
                        l(5) = errorbar(a, errorBarPositions(1,:), TP1Av, TP1Er, 'k.');
                        l(6) = errorbar(a, errorBarPositions(2,:), FA2Av, FA2Er, 'k.');
                        l(7) = errorbar(a, errorBarPositions(3,:), TP2Av, TP2Er, 'k.');
                        l(8) = errorbar(a, errorBarPositions(4,:), FA1Av, FA1Er, 'k.');
                        
                        %                 set(l([6 8]), 'Color', [0 .5 0]);
                        set(l(5:8), 'LineWidth', 1);
                        %                 set(l, 'MarkerSize', ordersMarkerSize);
                        legend('True Positive A', 'False Alarm B', 'True Positive B', 'False Alarm A');
                        title(sprintf('n = %d, P[A] = %0.3f, P[B] = %0.3f', numel(eR1Trimmed), fractionOfTotal(eR1Trimmed), fractionOfTotal(eR2Trimmed)), 'fontsize', plotFontSize);
                        xlabel('Conditions');
                        ylabel('Response Fraction');
                        a.XTick = 1:length(TP1Av);
                        a.XTickLabels = ordersLabelsWithN;
                        a.XTickLabelRotation = 45;
                        set(findall(hOv,'-property','FontSize'),'FontSize',ordersFontSize)
                        ylim([0 1]);
                        xlim([0 (errorBarPositions(end,end) + 1)]);
                    end
                    
                    if ~(useSection && useGInput)
                        break; % Do not go through the while loop again, because the entire trial was used
                    end
                end
            end
            
            %% Save figures, if desired
            if (haveTimes || ~(useSection && useGInput)) && saveFigs
                % Save all figures
                if doOverviewPlot
                    %                     if savingExampleFigures
                    thisSaveFigOverviewPath = saveFigOverviewPath;
                    %                     else
                    %                         thisSaveFigOverviewPath = [saveFigOverviewPath sprintf('Trial%0.2d', trialNum) filesep];
                    %                     end
                    if ~exist(thisSaveFigOverviewPath, 'dir')
                        mkdir(thisSaveFigOverviewPath);
                    end
                    fName = sprintf('%sOverview_%s_%s_t%d%s.', thisSaveFigOverviewPath, dateStr, timeStr, trialNum, clipString);
                    saveFigure(hOv, [fName saveFigsPicType]);
                    savefig(hOv, [fName 'fig']);
                end
                
                if thisDoTracesPlot
                    %                     if savingExampleFigures
                    thisSaveFigTracesPath = saveFigTracesPath;
                    %                     else
                    %                         thisSaveFigTracesPath = [saveFigTracesPath sprintf('Trial%0.2d', trialNum) filesep];
                    %                     end
                    if ~exist(thisSaveFigTracesPath, 'dir')
                        mkdir(thisSaveFigTracesPath);
                    end
                    if useFilteredTraces
                        rwStr = '';
                    else
                        rwStr = 'raw';
                    end
                    
                    for i = 1:numCases
                        switch i
                            case {1, 3}
                                % Looking at Unit 1's responses
                                unitStr = 'A';
                            case {2, 4}
                                % Looking at Unit 2's responses
                                unitStr = 'B';
                        end
                        switch i
                            case {1, 2}
                                expectedStr = 'A';
                            case {3, 4}
                                expectedStr = 'B';
                        end
                        
                        fNamealgn = sprintf('%sTr%sE%sSpkalgn%s_%s_%s%s.', thisSaveFigTracesPath, unitStr, expectedStr, rwStr, dateStr, timeStr, clipString);
                        saveFigure(hTrSpkalgn(i), [fNamealgn saveFigsPicType]);
                        savefig(hTrSpkalgn(i), [fNamealgn 'fig']);
                        
                        fNamena = sprintf('%sTr%sE%sSpkna%s_%s_%s%s.', thisSaveFigTracesPath, unitStr, expectedStr, rwStr, dateStr, timeStr, clipString);
                        saveFigure(hTrSpkna(i), [fNamena saveFigsPicType]);
                        savefig(hTrSpkna(i), [fNamena 'fig']);
                        
                        fNamealgn = sprintf('%sTr%sE%sNoSpkalgn%s_%s_%s%s.', thisSaveFigTracesPath, unitStr, expectedStr, rwStr, dateStr, timeStr, clipString);
                        saveFigure(hTrNoSpkalgn(i), [fNamealgn saveFigsPicType]);
                        savefig(hTrNoSpkalgn(i), [fNamealgn 'fig']);
                        
                        fNamena = sprintf('%sTr%sE%sNoSpkna%s_%s_%s%s.', thisSaveFigTracesPath, unitStr, expectedStr, rwStr, dateStr, timeStr, clipString);
                        saveFigure(hTrNoSpkna(i), [fNamena saveFigsPicType]);
                        savefig(hTrNoSpkna(i), [fNamena 'fig']);
                        
                        if i <= 2
                            fNamealgn = sprintf('%sCmp_Tr%sSpkalgn%s_%s_%s%s.', thisSaveFigTracesPath, unitStr, rwStr, dateStr, timeStr, clipString);
                            saveFigure(hTrCmpSpkalgn(i), [fNamealgn saveFigsPicType]);
                            savefig(hTrCmpSpkalgn(i), [fNamealgn 'fig']);
                            
                            fNamena = sprintf('%sCmp_Tr%sSpkna%s_%s_%s%s.', thisSaveFigTracesPath, unitStr, rwStr, dateStr, timeStr, clipString);
                            saveFigure(hTrCmpSpkna(i), [fNamena saveFigsPicType]);
                            savefig(hTrCmpSpkna(i), [fNamena 'fig']);
                            
                            fNamealgn = sprintf('%sCmp_Tr%sNoSpkalgn%s_%s_%s%s.', thisSaveFigTracesPath, unitStr, rwStr, dateStr, timeStr, clipString);
                            saveFigure(hTrCmpNoSpkalgn(i), [fNamealgn saveFigsPicType]);
                            savefig(hTrCmpNoSpkalgn(i), [fNamealgn 'fig']);
                            
                            fNamena = sprintf('%sCmp_Tr%sNoSpkna%s_%s_%s%s.', thisSaveFigTracesPath, unitStr, rwStr, dateStr, timeStr, clipString);
                            saveFigure(hTrCmpNoSpkna(i), [fNamena saveFigsPicType]);
                            savefig(hTrCmpNoSpkna(i), [fNamena 'fig']);
                        end
                    end
                end
                
                if doTrimmedPerfOverTimePlot
                    %                     if savingExampleFigures
                    thisSaveFigTrimmedPerfOverTimePath = saveFigTrimmedPerfOverTimePath;
                    %                     else
                    %                         thisSaveFigTrimmedPerfOverTimePath = [saveFigTrimmedPerfOverTimePath sprintf('Trial%0.2d', trialNum) filesep];
                    %                     end
                    if ~exist(thisSaveFigTrimmedPerfOverTimePath, 'dir')
                        mkdir(thisSaveFigTrimmedPerfOverTimePath);
                    end
                    
                    fName = sprintf('%sTrimmedPerfOverTime_%s_%s%s.', thisSaveFigTrimmedPerfOverTimePath, dateStr, timeStr, clipString);
                    saveFigure(hTPOT, [fName saveFigsPicType]);
                    savefig(hTPOT, [fName 'fig']);
                end
                
                if doProbTrajPlot
                    %                     if savingExampleFigures
                    thisSaveFigProbTraj = saveFigProbTraj;
                    %                     else
                    %                         thisSaveFigProbTraj = [saveFigProbTraj sprintf('Trial%0.2d', trialNum) filesep];
                    %                     end
                    if ~exist(thisSaveFigProbTraj, 'dir')
                        mkdir(thisSaveFigProbTraj);
                    end
                    
                    fName1 = sprintf('%sProbTrajA_%s_%s%s.', thisSaveFigProbTraj, dateStr, timeStr, clipString);
                    saveFigure(hPT1, [fName1 saveFigsPicType]);
                    savefig(hPT1, [fName1 'fig']);
                    fName2 = sprintf('%sProbTrajB_%s_%s%s.', thisSaveFigProbTraj, dateStr, timeStr, clipString);
                    saveFigure(hPT2, [fName2 saveFigsPicType]);
                    savefig(hPT2, [fName2 'fig']);
                end
                
                if doPerfOverTimePlot
                    %                     if savingExampleFigures
                    thisSaveFigPerfOverTimePath = saveFigPerfOverTimePath;
                    %                     else
                    %                         thisSaveFigPerfOverTimePath = [saveFigPerfOverTimePath sprintf('Trial%0.2d', trialNum) filesep];
                    %                     end
                    if ~exist(thisSaveFigPerfOverTimePath, 'dir')
                        mkdir(thisSaveFigPerfOverTimePath);
                    end
                    
                    fName = sprintf('%sPerfOverTime_%s_%s%s.', thisSaveFigPerfOverTimePath, dateStr, timeStr, clipString);
                    saveFigure(hPOT, [fName saveFigsPicType]);
                    savefig(hPOT, [fName 'fig']);
                    
                    if hasERPlot && doEpochResultsPlot
                        fName = sprintf('%sEpochResults_%s_%s%s.', thisSaveFigPerfOverTimePath, dateStr, timeStr, clipString);
                        saveFigure(hER, [fName saveFigsPicType]);
                        savefig(hER, [fName 'fig']);
                    end
                    
                    if doAdapt && doCostOverTimePlot
                        fName = sprintf('%sCostOverTime_%s_%s%s.', thisSaveFigPerfOverTimePath, dateStr, timeStr, clipString);
                        saveFigure(hCOT, [fName saveFigsPicType]);
                        savefig(hCOT, [fName 'fig']);
                    end
                end
                
                if doPerfPerBlockPlot
                    %                     if savingExampleFigures
                    thisSaveFigPerfPerBlockPath = saveFigPerfPerBlockPath;
                    %                     else
                    %                         thisSaveFigPerfPerBlockPath = [saveFigPerfPerBlockPath sprintf('Trial%0.2d', trialNum) filesep];
                    %                     end
                    if ~exist(thisSaveFigPerfPerBlockPath, 'dir')
                        mkdir(thisSaveFigPerfPerBlockPath);
                    end
                    
                    fName = sprintf('%sPerfPerBlock_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                    saveFigure(hPPB, [fName saveFigsPicType]);
                    savefig(hPPB, [fName 'fig']);
                    
                    fName = sprintf('%sCostPerBlock_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                    saveFigure(hCPB, [fName saveFigsPicType]);
                    savefig(hCPB, [fName 'fig']);
                    
                    fName = sprintf('%sGT1PerBlock_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                    saveFigure(hGTT1, [fName saveFigsPicType]);
                    savefig(hGTT1, [fName 'fig']);
                    
                    fName = sprintf('%sGT2PerBlock_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                    saveFigure(hGTT2, [fName saveFigsPicType]);
                    savefig(hGTT2, [fName 'fig']);
                    
                    fName = sprintf('%sGTOverTimePerBlock_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                    saveFigure(hGTD, [fName saveFigsPicType]);
                    savefig(hGTD, [fName 'fig']);
                    
                    fName = sprintf('%sParametersOverTimePerBlock_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                    saveFigure(hNPT, [fName saveFigsPicType]);
                    savefig(hNPT, [fName 'fig']);
                    
                    if doPlotRfVsDeviance
                        fName = sprintf('%sResponseFracVsDeviance_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                        saveFigure(hRFvD, [fName saveFigsPicType]);
                        savefig(hRFvD, [fName 'fig']);
                    end
                    
                    if doPlotRFDifference
                        fName = sprintf('%sResponseFracDifference_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                        saveFigure(hRFD, [fName saveFigsPicType]);
                        savefig(hRFD, [fName 'fig']);
                        
                        fName = sprintf('%sResponseFracStateSpace_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                        saveFigure(hRFSS, [fName saveFigsPicType]);
                        savefig(hRFSS, [fName 'fig']);
                    end
                    
                    if doPerfInGTHeatmap
                        fName = sprintf('%sGTHeatmapA_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                        saveFigure(hGTHMA, [fName saveFigsPicType]);
                        savefig(hGTHMA, [fName 'fig']);
                        
                        fName = sprintf('%sGTHeatmapB_%s_%s%s.', thisSaveFigPerfPerBlockPath, dateStr, timeStr, clipString);
                        saveFigure(hGTHMB, [fName saveFigsPicType]);
                        savefig(hGTHMB, [fName 'fig']);
                    end
                end
                
                if thisDoCompareTracesPlot
                    %                     if savingExampleFigures
                    thisSaveFigCompareTracesPath = saveFigCompareTracesPath;
                    %                     else
                    %                         thisSaveFigCompareTracesPath = [saveFigCompareTracesPath sprintf('Trial%0.2d%s', trialNum, filesep)];
                    %                     end
                    if ~exist(thisSaveFigCompareTracesPath, 'dir')
                        mkdir(thisSaveFigCompareTracesPath);
                    end
                    
                    if useFilteredTraces
                        rwStr = '';
                    else
                        rwStr = 'raw';
                    end
                    
                    for i = 1:numCases
                        switch i
                            case {1, 3}
                                unitStr = 'A';
                                figInd = 1;
                            case {2, 4}
                                unitStr = 'B';
                                figInd = 2;
                        end
                        
                        thisHSpkCTAllalgn = halgnSpkCTAll(figInd);
                        thisHNoSpkCTAllalgn = halgnNoSpkCTAll(figInd);
                        thisHSpkCTAllna = hnaSpkCTAll(figInd);
                        thisHNoSpkCTAllna = hnaNoSpkCTAll(figInd);
                        
                        switch i
                            case {1, 4}
                                spikeStr = 'Spike';
                                thisHCTAllalgn = thisHSpkCTAllalgn;
                                thisHCTAllna = thisHSpkCTAllna;
                            case {2, 3}
                                spikeStr = 'No Spike';
                                thisHCTAllalgn = thisHNoSpkCTAllalgn;
                                thisHCTAllna = thisHNoSpkCTAllna;
                        end
                        
                        for segNum = 1:numCompareSegments
                            fNamealgn = sprintf('%sCompareTraceUnit%s%sS%0.2d%salgn%s_%s%s.', thisSaveFigCompareTracesPath, unitStr, spikeStr, segNum, rwStr, dateStr, timeStr, clipString);
                            saveFigure(halgnCT(i, segNum), [fNamealgn saveFigsPicType]);
                            savefig(halgnCT(i, segNum), [fNamealgn 'fig']);
                            fNamena = sprintf('%sCompareTraceUnit%s%sS%0.2d%s_%s_%s%s.', thisSaveFigCompareTracesPath, unitStr, spikeStr, segNum, rwStr, dateStr, timeStr, clipString);
                            saveFigure(hnaCT(i, segNum), [fNamena saveFigsPicType]);
                            savefig(hnaCT(i, segNum), [fNamena 'fig']);
                        end
                        %                     fName = sprintf('%sCompareTracePOT_CMP%s_%s_t%d%s.', thisSaveFigCompareTracesPath, dateStr, timeStr, trialNum, clipString);
                        %                     saveFigure(hCTPOT, [fName saveFigsPicType]);
                        %                     savefig(hCTPOT, [fName 'fig']);
                        
                        fName = sprintf('%sCompareTraceUnit%s%s_Allalgn%s_%s%s.', thisSaveFigCompareTracesPath, unitStr, spikeStr, dateStr, timeStr, clipString);
                        saveFigure(thisHCTAllalgn, [fName saveFigsPicType]);
                        savefig(thisHCTAllalgn, [fName 'fig']);
                        fName = sprintf('%sCompareTraceUnit%s%s_All%s_%s%s.', thisSaveFigCompareTracesPath, unitStr, spikeStr, dateStr, timeStr, clipString);
                        saveFigure(thisHCTAllna, [fName saveFigsPicType]);
                        savefig(thisHCTAllna, [fName 'fig']);
                    end
                    
                end
                
                close all;
            end
            
            %% Save a file that contains the important information from this run
            if thisGenerateAnalysisData
                thisAnalysisFileName = [thisAnalysisDataDir filesep analysisDataFileBase shortenedStr '_' dateStr '_' timeStr '_t' num2str(trialIndsInd) '.mat'];
                
                % Variables to save:
                runOrdersT;
                stimTimes1;
                eRAll1;
                vT1;
                vT2;
                spikeHitInds;
                doAdapt;
                epochStartInds;
                thisTrialResultsData1;
                thisTrialResultsData2;
                stimStrengthsThisTrial;
                stimDurationsThisTrial;
                adaptiveInfo1;
                adaptiveInfo2;
                allG1;
                %                 G1;
                allT1;
                allG2;
                %                 G2;
                allT2;
                iS;
                numSequences;
                numUnits;
                save(thisAnalysisFileName, 'runOrdersT', 'stimTimes1', 'eRAll1', 'vT1', 'vT2', 'spikeHitInds', 'doAdapt', 'epochStartInds', 'thisTrialResultsData1', 'thisTrialResultsData2', 'stimStrengthsThisTrial', 'stimDurationsThisTrial', 'adaptiveInfo1', 'adaptiveInfo2', 'allT1', 'allT2', 'iS', 'numSequences', 'numUnits');
%                 save(thisAnalysisFileName, 'runOrdersT', 'stimTimes1', 'eRAll1', 'vT1', 'vT2', 'spikeHitInds', 'doAdapt', 'epochStartInds', 'thisTrialResultsData1', 'thisTrialResultsData2', 'stimStrengthsThisTrial', 'adaptiveInfo1', 'adaptiveInfo2', 'idealG1', 'G1', 'allT1', 'idealG2', 'G2', 'allT2', 'thisIS', 'numSequences', 'numUnits');
            end
        end
    end
    %     catch e
    %         fprintf('Error running file %s_%s, threw Exception: %s', dateStr, timeStr, getReport(e));
    %     end
end